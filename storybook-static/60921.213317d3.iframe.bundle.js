"use strict";(self.webpackChunkcasaora=self.webpackChunkcasaora||[]).push([[60921],{"./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0});const PostgrestError_1=__webpack_require__("./node_modules/tslib/tslib.es6.mjs").__importDefault(__webpack_require__("./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js"));exports.default=class PostgrestBuilder{constructor(builder){var _a,_b;this.shouldThrowOnError=!1,this.method=builder.method,this.url=builder.url,this.headers=new Headers(builder.headers),this.schema=builder.schema,this.body=builder.body,this.shouldThrowOnError=null!==(_a=builder.shouldThrowOnError)&&void 0!==_a&&_a,this.signal=builder.signal,this.isMaybeSingle=null!==(_b=builder.isMaybeSingle)&&void 0!==_b&&_b,builder.fetch?this.fetch=builder.fetch:this.fetch=fetch}throwOnError(){return this.shouldThrowOnError=!0,this}setHeader(name,value){return this.headers=new Headers(this.headers),this.headers.set(name,value),this}then(onfulfilled,onrejected){void 0===this.schema||(["GET","HEAD"].includes(this.method)?this.headers.set("Accept-Profile",this.schema):this.headers.set("Content-Profile",this.schema)),"GET"!==this.method&&"HEAD"!==this.method&&this.headers.set("Content-Type","application/json");let res=(0,this.fetch)(this.url.toString(),{method:this.method,headers:this.headers,body:JSON.stringify(this.body),signal:this.signal}).then(async res=>{var _a,_b,_c,_d;let error=null,data=null,count=null,status=res.status,statusText=res.statusText;if(res.ok){if("HEAD"!==this.method){const body=await res.text();""===body||(data="text/csv"===this.headers.get("Accept")||this.headers.get("Accept")&&(null===(_a=this.headers.get("Accept"))||void 0===_a?void 0:_a.includes("application/vnd.pgrst.plan+text"))?body:JSON.parse(body))}const countHeader=null===(_b=this.headers.get("Prefer"))||void 0===_b?void 0:_b.match(/count=(exact|planned|estimated)/),contentRange=null===(_c=res.headers.get("content-range"))||void 0===_c?void 0:_c.split("/");countHeader&&contentRange&&contentRange.length>1&&(count=parseInt(contentRange[1])),this.isMaybeSingle&&"GET"===this.method&&Array.isArray(data)&&(data.length>1?(error={code:"PGRST116",details:`Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,hint:null,message:"JSON object requested, multiple (or no) rows returned"},data=null,count=null,status=406,statusText="Not Acceptable"):data=1===data.length?data[0]:null)}else{const body=await res.text();try{error=JSON.parse(body),Array.isArray(error)&&404===res.status&&(data=[],error=null,status=200,statusText="OK")}catch(_e){404===res.status&&""===body?(status=204,statusText="No Content"):error={message:body}}if(error&&this.isMaybeSingle&&(null===(_d=null==error?void 0:error.details)||void 0===_d?void 0:_d.includes("0 rows"))&&(error=null,status=200,statusText="OK"),error&&this.shouldThrowOnError)throw new PostgrestError_1.default(error)}return{error,data,count,status,statusText}});return this.shouldThrowOnError||(res=res.catch(fetchError=>{var _a,_b,_c;return{error:{message:`${null!==(_a=null==fetchError?void 0:fetchError.name)&&void 0!==_a?_a:"FetchError"}: ${null==fetchError?void 0:fetchError.message}`,details:`${null!==(_b=null==fetchError?void 0:fetchError.stack)&&void 0!==_b?_b:""}`,hint:"",code:`${null!==(_c=null==fetchError?void 0:fetchError.code)&&void 0!==_c?_c:""}`},data:null,count:null,status:0,statusText:""}})),res.then(onfulfilled,onrejected)}returns(){return this}overrideTypes(){return this}}},"./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0});const tslib_1=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),PostgrestQueryBuilder_1=tslib_1.__importDefault(__webpack_require__("./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js")),PostgrestFilterBuilder_1=tslib_1.__importDefault(__webpack_require__("./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js"));class PostgrestClient{constructor(url,{headers={},schema,fetch}={}){this.url=url,this.headers=new Headers(headers),this.schemaName=schema,this.fetch=fetch}from(relation){const url=new URL(`${this.url}/${relation}`);return new PostgrestQueryBuilder_1.default(url,{headers:new Headers(this.headers),schema:this.schemaName,fetch:this.fetch})}schema(schema){return new PostgrestClient(this.url,{headers:this.headers,schema,fetch:this.fetch})}rpc(fn,args={},{head=!1,get=!1,count}={}){var _a;let method;const url=new URL(`${this.url}/rpc/${fn}`);let body;head||get?(method=head?"HEAD":"GET",Object.entries(args).filter(([_,value])=>void 0!==value).map(([name,value])=>[name,Array.isArray(value)?`{${value.join(",")}}`:`${value}`]).forEach(([name,value])=>{url.searchParams.append(name,value)})):(method="POST",body=args);const headers=new Headers(this.headers);return count&&headers.set("Prefer",`count=${count}`),new PostgrestFilterBuilder_1.default({method,url,headers,schema:this.schemaName,body,fetch:null!==(_a=this.fetch)&&void 0!==_a?_a:fetch})}}exports.default=PostgrestClient},"./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js":(__unused_webpack_module,exports)=>{Object.defineProperty(exports,"__esModule",{value:!0});class PostgrestError extends Error{constructor(context){super(context.message),this.name="PostgrestError",this.details=context.details,this.hint=context.hint,this.code=context.code}}exports.default=PostgrestError},"./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0});const PostgrestTransformBuilder_1=__webpack_require__("./node_modules/tslib/tslib.es6.mjs").__importDefault(__webpack_require__("./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js")),PostgrestReservedCharsRegexp=new RegExp("[,()]");class PostgrestFilterBuilder extends PostgrestTransformBuilder_1.default{eq(column,value){return this.url.searchParams.append(column,`eq.${value}`),this}neq(column,value){return this.url.searchParams.append(column,`neq.${value}`),this}gt(column,value){return this.url.searchParams.append(column,`gt.${value}`),this}gte(column,value){return this.url.searchParams.append(column,`gte.${value}`),this}lt(column,value){return this.url.searchParams.append(column,`lt.${value}`),this}lte(column,value){return this.url.searchParams.append(column,`lte.${value}`),this}like(column,pattern){return this.url.searchParams.append(column,`like.${pattern}`),this}likeAllOf(column,patterns){return this.url.searchParams.append(column,`like(all).{${patterns.join(",")}}`),this}likeAnyOf(column,patterns){return this.url.searchParams.append(column,`like(any).{${patterns.join(",")}}`),this}ilike(column,pattern){return this.url.searchParams.append(column,`ilike.${pattern}`),this}ilikeAllOf(column,patterns){return this.url.searchParams.append(column,`ilike(all).{${patterns.join(",")}}`),this}ilikeAnyOf(column,patterns){return this.url.searchParams.append(column,`ilike(any).{${patterns.join(",")}}`),this}is(column,value){return this.url.searchParams.append(column,`is.${value}`),this}in(column,values){const cleanedValues=Array.from(new Set(values)).map(s=>"string"==typeof s&&PostgrestReservedCharsRegexp.test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(column,`in.(${cleanedValues})`),this}contains(column,value){return"string"==typeof value?this.url.searchParams.append(column,`cs.${value}`):Array.isArray(value)?this.url.searchParams.append(column,`cs.{${value.join(",")}}`):this.url.searchParams.append(column,`cs.${JSON.stringify(value)}`),this}containedBy(column,value){return"string"==typeof value?this.url.searchParams.append(column,`cd.${value}`):Array.isArray(value)?this.url.searchParams.append(column,`cd.{${value.join(",")}}`):this.url.searchParams.append(column,`cd.${JSON.stringify(value)}`),this}rangeGt(column,range){return this.url.searchParams.append(column,`sr.${range}`),this}rangeGte(column,range){return this.url.searchParams.append(column,`nxl.${range}`),this}rangeLt(column,range){return this.url.searchParams.append(column,`sl.${range}`),this}rangeLte(column,range){return this.url.searchParams.append(column,`nxr.${range}`),this}rangeAdjacent(column,range){return this.url.searchParams.append(column,`adj.${range}`),this}overlaps(column,value){return"string"==typeof value?this.url.searchParams.append(column,`ov.${value}`):this.url.searchParams.append(column,`ov.{${value.join(",")}}`),this}textSearch(column,query,{config,type}={}){let typePart="";"plain"===type?typePart="pl":"phrase"===type?typePart="ph":"websearch"===type&&(typePart="w");const configPart=void 0===config?"":`(${config})`;return this.url.searchParams.append(column,`${typePart}fts${configPart}.${query}`),this}match(query){return Object.entries(query).forEach(([column,value])=>{this.url.searchParams.append(column,`eq.${value}`)}),this}not(column,operator,value){return this.url.searchParams.append(column,`not.${operator}.${value}`),this}or(filters,{foreignTable,referencedTable=foreignTable}={}){const key=referencedTable?`${referencedTable}.or`:"or";return this.url.searchParams.append(key,`(${filters})`),this}filter(column,operator,value){return this.url.searchParams.append(column,`${operator}.${value}`),this}}exports.default=PostgrestFilterBuilder},"./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0});const PostgrestFilterBuilder_1=__webpack_require__("./node_modules/tslib/tslib.es6.mjs").__importDefault(__webpack_require__("./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js"));exports.default=class PostgrestQueryBuilder{constructor(url,{headers={},schema,fetch}){this.url=url,this.headers=new Headers(headers),this.schema=schema,this.fetch=fetch}select(columns,options){const{head=!1,count}=null!=options?options:{},method=head?"HEAD":"GET";let quoted=!1;const cleanedColumns=(null!=columns?columns:"*").split("").map(c=>/\s/.test(c)&&!quoted?"":('"'===c&&(quoted=!quoted),c)).join("");return this.url.searchParams.set("select",cleanedColumns),count&&this.headers.append("Prefer",`count=${count}`),new PostgrestFilterBuilder_1.default({method,url:this.url,headers:this.headers,schema:this.schema,fetch:this.fetch})}insert(values,{count,defaultToNull=!0}={}){var _a;if(count&&this.headers.append("Prefer",`count=${count}`),defaultToNull||this.headers.append("Prefer","missing=default"),Array.isArray(values)){const columns=values.reduce((acc,x)=>acc.concat(Object.keys(x)),[]);if(columns.length>0){const uniqueColumns=[...new Set(columns)].map(column=>`"${column}"`);this.url.searchParams.set("columns",uniqueColumns.join(","))}}return new PostgrestFilterBuilder_1.default({method:"POST",url:this.url,headers:this.headers,schema:this.schema,body:values,fetch:null!==(_a=this.fetch)&&void 0!==_a?_a:fetch})}upsert(values,{onConflict,ignoreDuplicates=!1,count,defaultToNull=!0}={}){var _a;if(this.headers.append("Prefer",`resolution=${ignoreDuplicates?"ignore":"merge"}-duplicates`),void 0!==onConflict&&this.url.searchParams.set("on_conflict",onConflict),count&&this.headers.append("Prefer",`count=${count}`),defaultToNull||this.headers.append("Prefer","missing=default"),Array.isArray(values)){const columns=values.reduce((acc,x)=>acc.concat(Object.keys(x)),[]);if(columns.length>0){const uniqueColumns=[...new Set(columns)].map(column=>`"${column}"`);this.url.searchParams.set("columns",uniqueColumns.join(","))}}return new PostgrestFilterBuilder_1.default({method:"POST",url:this.url,headers:this.headers,schema:this.schema,body:values,fetch:null!==(_a=this.fetch)&&void 0!==_a?_a:fetch})}update(values,{count}={}){var _a;return count&&this.headers.append("Prefer",`count=${count}`),new PostgrestFilterBuilder_1.default({method:"PATCH",url:this.url,headers:this.headers,schema:this.schema,body:values,fetch:null!==(_a=this.fetch)&&void 0!==_a?_a:fetch})}delete({count}={}){var _a;return count&&this.headers.append("Prefer",`count=${count}`),new PostgrestFilterBuilder_1.default({method:"DELETE",url:this.url,headers:this.headers,schema:this.schema,fetch:null!==(_a=this.fetch)&&void 0!==_a?_a:fetch})}}},"./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0});const PostgrestBuilder_1=__webpack_require__("./node_modules/tslib/tslib.es6.mjs").__importDefault(__webpack_require__("./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js"));class PostgrestTransformBuilder extends PostgrestBuilder_1.default{select(columns){let quoted=!1;const cleanedColumns=(null!=columns?columns:"*").split("").map(c=>/\s/.test(c)&&!quoted?"":('"'===c&&(quoted=!quoted),c)).join("");return this.url.searchParams.set("select",cleanedColumns),this.headers.append("Prefer","return=representation"),this}order(column,{ascending=!0,nullsFirst,foreignTable,referencedTable=foreignTable}={}){const key=referencedTable?`${referencedTable}.order`:"order",existingOrder=this.url.searchParams.get(key);return this.url.searchParams.set(key,`${existingOrder?`${existingOrder},`:""}${column}.${ascending?"asc":"desc"}${void 0===nullsFirst?"":nullsFirst?".nullsfirst":".nullslast"}`),this}limit(count,{foreignTable,referencedTable=foreignTable}={}){const key=void 0===referencedTable?"limit":`${referencedTable}.limit`;return this.url.searchParams.set(key,`${count}`),this}range(from,to,{foreignTable,referencedTable=foreignTable}={}){const keyOffset=void 0===referencedTable?"offset":`${referencedTable}.offset`,keyLimit=void 0===referencedTable?"limit":`${referencedTable}.limit`;return this.url.searchParams.set(keyOffset,`${from}`),this.url.searchParams.set(keyLimit,""+(to-from+1)),this}abortSignal(signal){return this.signal=signal,this}single(){return this.headers.set("Accept","application/vnd.pgrst.object+json"),this}maybeSingle(){return"GET"===this.method?this.headers.set("Accept","application/json"):this.headers.set("Accept","application/vnd.pgrst.object+json"),this.isMaybeSingle=!0,this}csv(){return this.headers.set("Accept","text/csv"),this}geojson(){return this.headers.set("Accept","application/geo+json"),this}explain({analyze=!1,verbose=!1,settings=!1,buffers=!1,wal=!1,format="text"}={}){var _a;const options=[analyze?"analyze":null,verbose?"verbose":null,settings?"settings":null,buffers?"buffers":null,wal?"wal":null].filter(Boolean).join("|"),forMediatype=null!==(_a=this.headers.get("Accept"))&&void 0!==_a?_a:"application/json";return this.headers.set("Accept",`application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`),this}rollback(){return this.headers.append("Prefer","tx=rollback"),this}returns(){return this}maxAffected(value){return this.headers.append("Prefer","handling=strict"),this.headers.append("Prefer",`max-affected=${value}`),this}}exports.default=PostgrestTransformBuilder},"./node_modules/@supabase/postgrest-js/dist/cjs/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.PostgrestError=exports.PostgrestBuilder=exports.PostgrestTransformBuilder=exports.PostgrestFilterBuilder=exports.PostgrestQueryBuilder=exports.PostgrestClient=void 0;const tslib_1=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),PostgrestClient_1=tslib_1.__importDefault(__webpack_require__("./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js"));exports.PostgrestClient=PostgrestClient_1.default;const PostgrestQueryBuilder_1=tslib_1.__importDefault(__webpack_require__("./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js"));exports.PostgrestQueryBuilder=PostgrestQueryBuilder_1.default;const PostgrestFilterBuilder_1=tslib_1.__importDefault(__webpack_require__("./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js"));exports.PostgrestFilterBuilder=PostgrestFilterBuilder_1.default;const PostgrestTransformBuilder_1=tslib_1.__importDefault(__webpack_require__("./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js"));exports.PostgrestTransformBuilder=PostgrestTransformBuilder_1.default;const PostgrestBuilder_1=tslib_1.__importDefault(__webpack_require__("./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js"));exports.PostgrestBuilder=PostgrestBuilder_1.default;const PostgrestError_1=tslib_1.__importDefault(__webpack_require__("./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js"));exports.PostgrestError=PostgrestError_1.default,exports.default={PostgrestClient:PostgrestClient_1.default,PostgrestQueryBuilder:PostgrestQueryBuilder_1.default,PostgrestFilterBuilder:PostgrestFilterBuilder_1.default,PostgrestTransformBuilder:PostgrestTransformBuilder_1.default,PostgrestBuilder:PostgrestBuilder_1.default,PostgrestError:PostgrestError_1.default}},"./node_modules/@supabase/ssr/dist/module/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{createBrowserClient:()=>createBrowserClient,createServerClient:()=>createServerClient});var tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs");class FunctionsError extends Error{constructor(message,name="FunctionsError",context){super(message),this.name=name,this.context=context}}class FunctionsFetchError extends FunctionsError{constructor(context){super("Failed to send a request to the Edge Function","FunctionsFetchError",context)}}class FunctionsRelayError extends FunctionsError{constructor(context){super("Relay Error invoking the Edge Function","FunctionsRelayError",context)}}class FunctionsHttpError extends FunctionsError{constructor(context){super("Edge Function returned a non-2xx status code","FunctionsHttpError",context)}}var FunctionRegion;!function(FunctionRegion){FunctionRegion.Any="any",FunctionRegion.ApNortheast1="ap-northeast-1",FunctionRegion.ApNortheast2="ap-northeast-2",FunctionRegion.ApSouth1="ap-south-1",FunctionRegion.ApSoutheast1="ap-southeast-1",FunctionRegion.ApSoutheast2="ap-southeast-2",FunctionRegion.CaCentral1="ca-central-1",FunctionRegion.EuCentral1="eu-central-1",FunctionRegion.EuWest1="eu-west-1",FunctionRegion.EuWest2="eu-west-2",FunctionRegion.EuWest3="eu-west-3",FunctionRegion.SaEast1="sa-east-1",FunctionRegion.UsEast1="us-east-1",FunctionRegion.UsWest1="us-west-1",FunctionRegion.UsWest2="us-west-2"}(FunctionRegion||(FunctionRegion={}));class FunctionsClient{constructor(url,{headers={},customFetch,region=FunctionRegion.Any}={}){this.url=url,this.headers=headers,this.region=region,this.fetch=(customFetch=>customFetch?(...args)=>customFetch(...args):(...args)=>fetch(...args))(customFetch)}setAuth(token){this.headers.Authorization=`Bearer ${token}`}invoke(functionName_1){return(0,tslib_es6.__awaiter)(this,arguments,void 0,function*(functionName,options={}){var _a;try{const{headers,method,body:functionArgs,signal}=options;let _headers={},{region}=options;region||(region=this.region);const url=new URL(`${this.url}/${functionName}`);let body;region&&"any"!==region&&(_headers["x-region"]=region,url.searchParams.set("forceFunctionRegion",region)),functionArgs&&(headers&&!Object.prototype.hasOwnProperty.call(headers,"Content-Type")||!headers)?"undefined"!=typeof Blob&&functionArgs instanceof Blob||functionArgs instanceof ArrayBuffer?(_headers["Content-Type"]="application/octet-stream",body=functionArgs):"string"==typeof functionArgs?(_headers["Content-Type"]="text/plain",body=functionArgs):"undefined"!=typeof FormData&&functionArgs instanceof FormData?body=functionArgs:(_headers["Content-Type"]="application/json",body=JSON.stringify(functionArgs)):body=functionArgs;const response=yield this.fetch(url.toString(),{method:method||"POST",headers:Object.assign(Object.assign(Object.assign({},_headers),this.headers),headers),body,signal}).catch(fetchError=>{if("AbortError"===fetchError.name)throw fetchError;throw new FunctionsFetchError(fetchError)}),isRelayError=response.headers.get("x-relay-error");if(isRelayError&&"true"===isRelayError)throw new FunctionsRelayError(response);if(!response.ok)throw new FunctionsHttpError(response);let data,responseType=(null!==(_a=response.headers.get("Content-Type"))&&void 0!==_a?_a:"text/plain").split(";")[0].trim();return data="application/json"===responseType?yield response.json():"application/octet-stream"===responseType||"application/pdf"===responseType?yield response.blob():"text/event-stream"===responseType?response:"multipart/form-data"===responseType?yield response.formData():yield response.text(),{data,error:null,response}}catch(error){return error instanceof Error&&"AbortError"===error.name?{data:null,error:new FunctionsFetchError(error)}:{data:null,error,response:error instanceof FunctionsHttpError||error instanceof FunctionsRelayError?error.context:void 0}}})}}var cjs=__webpack_require__("./node_modules/@supabase/postgrest-js/dist/cjs/index.js");const{PostgrestClient,PostgrestQueryBuilder,PostgrestFilterBuilder,PostgrestTransformBuilder,PostgrestBuilder,PostgrestError}=cjs.default||cjs;var process=__webpack_require__("./node_modules/process/browser.js");const websocket_factory=class WebSocketFactory{static detectEnvironment(){var _a;if("undefined"!=typeof WebSocket)return{type:"native",constructor:WebSocket};if("undefined"!=typeof globalThis&&void 0!==globalThis.WebSocket)return{type:"native",constructor:globalThis.WebSocket};if(void 0!==__webpack_require__.g&&void 0!==__webpack_require__.g.WebSocket)return{type:"native",constructor:__webpack_require__.g.WebSocket};if("undefined"!=typeof globalThis&&void 0!==globalThis.WebSocketPair&&void 0===globalThis.WebSocket)return{type:"cloudflare",error:"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",workaround:"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."};if("undefined"!=typeof globalThis&&globalThis.EdgeRuntime||"undefined"!=typeof navigator&&(null===(_a=navigator.userAgent)||void 0===_a?void 0:_a.includes("Vercel-Edge")))return{type:"unsupported",error:"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",workaround:"Use serverless functions or a different deployment target for WebSocket functionality."};if(void 0!==process){const processVersions=process.versions;if(processVersions&&processVersions.node){const versionString=processVersions.node,nodeVersion=parseInt(versionString.replace(/^v/,"").split(".")[0]);return nodeVersion>=22?void 0!==globalThis.WebSocket?{type:"native",constructor:globalThis.WebSocket}:{type:"unsupported",error:`Node.js ${nodeVersion} detected but native WebSocket not found.`,workaround:"Provide a WebSocket implementation via the transport option."}:{type:"unsupported",error:`Node.js ${nodeVersion} detected without native WebSocket support.`,workaround:'For Node.js < 22, install "ws" package and provide it via the transport option:\nimport ws from "ws"\nnew RealtimeClient(url, { transport: ws })'}}}return{type:"unsupported",error:"Unknown JavaScript runtime without WebSocket support.",workaround:"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."}}static getWebSocketConstructor(){const env=this.detectEnvironment();if(env.constructor)return env.constructor;let errorMessage=env.error||"WebSocket not supported in this environment.";throw env.workaround&&(errorMessage+=`\n\nSuggested solution: ${env.workaround}`),new Error(errorMessage)}static createWebSocket(url,protocols){return new(this.getWebSocketConstructor())(url,protocols)}static isWebSocketSupported(){try{const env=this.detectEnvironment();return"native"===env.type||"ws"===env.type}catch(_a){return!1}}};var SOCKET_STATES,constants_CHANNEL_STATES,CHANNEL_EVENTS,TRANSPORTS,CONNECTION_STATE;!function(SOCKET_STATES){SOCKET_STATES[SOCKET_STATES.connecting=0]="connecting",SOCKET_STATES[SOCKET_STATES.open=1]="open",SOCKET_STATES[SOCKET_STATES.closing=2]="closing",SOCKET_STATES[SOCKET_STATES.closed=3]="closed"}(SOCKET_STATES||(SOCKET_STATES={})),function(CHANNEL_STATES){CHANNEL_STATES.closed="closed",CHANNEL_STATES.errored="errored",CHANNEL_STATES.joined="joined",CHANNEL_STATES.joining="joining",CHANNEL_STATES.leaving="leaving"}(constants_CHANNEL_STATES||(constants_CHANNEL_STATES={})),function(CHANNEL_EVENTS){CHANNEL_EVENTS.close="phx_close",CHANNEL_EVENTS.error="phx_error",CHANNEL_EVENTS.join="phx_join",CHANNEL_EVENTS.reply="phx_reply",CHANNEL_EVENTS.leave="phx_leave",CHANNEL_EVENTS.access_token="access_token"}(CHANNEL_EVENTS||(CHANNEL_EVENTS={})),function(TRANSPORTS){TRANSPORTS.websocket="websocket"}(TRANSPORTS||(TRANSPORTS={})),function(CONNECTION_STATE){CONNECTION_STATE.Connecting="connecting",CONNECTION_STATE.Open="open",CONNECTION_STATE.Closing="closing",CONNECTION_STATE.Closed="closed"}(CONNECTION_STATE||(CONNECTION_STATE={}));class Serializer{constructor(){this.HEADER_LENGTH=1}decode(rawPayload,callback){return rawPayload.constructor===ArrayBuffer?callback(this._binaryDecode(rawPayload)):callback("string"==typeof rawPayload?JSON.parse(rawPayload):{})}_binaryDecode(buffer){const view=new DataView(buffer),decoder=new TextDecoder;return this._decodeBroadcast(buffer,view,decoder)}_decodeBroadcast(buffer,view,decoder){const topicSize=view.getUint8(1),eventSize=view.getUint8(2);let offset=this.HEADER_LENGTH+2;const topic=decoder.decode(buffer.slice(offset,offset+topicSize));offset+=topicSize;const event=decoder.decode(buffer.slice(offset,offset+eventSize));offset+=eventSize;return{ref:null,topic,event,payload:JSON.parse(decoder.decode(buffer.slice(offset,buffer.byteLength)))}}}class Timer{constructor(callback,timerCalc){this.callback=callback,this.timerCalc=timerCalc,this.timer=void 0,this.tries=0,this.callback=callback,this.timerCalc=timerCalc}reset(){this.tries=0,clearTimeout(this.timer),this.timer=void 0}scheduleTimeout(){clearTimeout(this.timer),this.timer=setTimeout(()=>{this.tries=this.tries+1,this.callback()},this.timerCalc(this.tries+1))}}var PostgresTypes,console=__webpack_require__("./node_modules/console-browserify/index.js");!function(PostgresTypes){PostgresTypes.abstime="abstime",PostgresTypes.bool="bool",PostgresTypes.date="date",PostgresTypes.daterange="daterange",PostgresTypes.float4="float4",PostgresTypes.float8="float8",PostgresTypes.int2="int2",PostgresTypes.int4="int4",PostgresTypes.int4range="int4range",PostgresTypes.int8="int8",PostgresTypes.int8range="int8range",PostgresTypes.json="json",PostgresTypes.jsonb="jsonb",PostgresTypes.money="money",PostgresTypes.numeric="numeric",PostgresTypes.oid="oid",PostgresTypes.reltime="reltime",PostgresTypes.text="text",PostgresTypes.time="time",PostgresTypes.timestamp="timestamp",PostgresTypes.timestamptz="timestamptz",PostgresTypes.timetz="timetz",PostgresTypes.tsrange="tsrange",PostgresTypes.tstzrange="tstzrange"}(PostgresTypes||(PostgresTypes={}));const convertChangeData=(columns,record,options={})=>{var _a;const skipTypes=null!==(_a=options.skipTypes)&&void 0!==_a?_a:[];return record?Object.keys(record).reduce((acc,rec_key)=>(acc[rec_key]=convertColumn(rec_key,columns,record,skipTypes),acc),{}):{}},convertColumn=(columnName,columns,record,skipTypes)=>{const column=columns.find(x=>x.name===columnName),colType=null==column?void 0:column.type,value=record[columnName];return colType&&!skipTypes.includes(colType)?convertCell(colType,value):noop(value)},convertCell=(type,value)=>{if("_"===type.charAt(0)){const dataType=type.slice(1,type.length);return toArray(value,dataType)}switch(type){case PostgresTypes.bool:return toBoolean(value);case PostgresTypes.float4:case PostgresTypes.float8:case PostgresTypes.int2:case PostgresTypes.int4:case PostgresTypes.int8:case PostgresTypes.numeric:case PostgresTypes.oid:return toNumber(value);case PostgresTypes.json:case PostgresTypes.jsonb:return toJson(value);case PostgresTypes.timestamp:return toTimestampString(value);case PostgresTypes.abstime:case PostgresTypes.date:case PostgresTypes.daterange:case PostgresTypes.int4range:case PostgresTypes.int8range:case PostgresTypes.money:case PostgresTypes.reltime:case PostgresTypes.text:case PostgresTypes.time:case PostgresTypes.timestamptz:case PostgresTypes.timetz:case PostgresTypes.tsrange:case PostgresTypes.tstzrange:default:return noop(value)}},noop=value=>value,toBoolean=value=>{switch(value){case"t":return!0;case"f":return!1;default:return value}},toNumber=value=>{if("string"==typeof value){const parsedValue=parseFloat(value);if(!Number.isNaN(parsedValue))return parsedValue}return value},toJson=value=>{if("string"==typeof value)try{return JSON.parse(value)}catch(error){return console.log(`JSON parse error: ${error}`),value}return value},toArray=(value,type)=>{if("string"!=typeof value)return value;const lastIdx=value.length-1,closeBrace=value[lastIdx];if("{"===value[0]&&"}"===closeBrace){let arr;const valTrim=value.slice(1,lastIdx);try{arr=JSON.parse("["+valTrim+"]")}catch(_){arr=valTrim?valTrim.split(","):[]}return arr.map(val=>convertCell(type,val))}return value},toTimestampString=value=>"string"==typeof value?value.replace(" ","T"):value,httpEndpointURL=socketUrl=>{const wsUrl=new URL(socketUrl);return wsUrl.protocol=wsUrl.protocol.replace(/^ws/i,"http"),wsUrl.pathname=wsUrl.pathname.replace(/\/+$/,"").replace(/\/socket\/websocket$/i,"").replace(/\/socket$/i,"").replace(/\/websocket$/i,""),""===wsUrl.pathname||"/"===wsUrl.pathname?wsUrl.pathname="/api/broadcast":wsUrl.pathname=wsUrl.pathname+"/api/broadcast",wsUrl.href};class Push{constructor(channel,event,payload={},timeout=1e4){this.channel=channel,this.event=event,this.payload=payload,this.timeout=timeout,this.sent=!1,this.timeoutTimer=void 0,this.ref="",this.receivedResp=null,this.recHooks=[],this.refEvent=null}resend(timeout){this.timeout=timeout,this._cancelRefEvent(),this.ref="",this.refEvent=null,this.receivedResp=null,this.sent=!1,this.send()}send(){this._hasReceived("timeout")||(this.startTimeout(),this.sent=!0,this.channel.socket.push({topic:this.channel.topic,event:this.event,payload:this.payload,ref:this.ref,join_ref:this.channel._joinRef()}))}updatePayload(payload){this.payload=Object.assign(Object.assign({},this.payload),payload)}receive(status,callback){var _a;return this._hasReceived(status)&&callback(null===(_a=this.receivedResp)||void 0===_a?void 0:_a.response),this.recHooks.push({status,callback}),this}startTimeout(){if(this.timeoutTimer)return;this.ref=this.channel.socket._makeRef(),this.refEvent=this.channel._replyEventName(this.ref);this.channel._on(this.refEvent,{},payload=>{this._cancelRefEvent(),this._cancelTimeout(),this.receivedResp=payload,this._matchReceive(payload)}),this.timeoutTimer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}trigger(status,response){this.refEvent&&this.channel._trigger(this.refEvent,{status,response})}destroy(){this._cancelRefEvent(),this._cancelTimeout()}_cancelRefEvent(){this.refEvent&&this.channel._off(this.refEvent,{})}_cancelTimeout(){clearTimeout(this.timeoutTimer),this.timeoutTimer=void 0}_matchReceive({status,response}){this.recHooks.filter(h=>h.status===status).forEach(h=>h.callback(response))}_hasReceived(status){return this.receivedResp&&this.receivedResp.status===status}}var REALTIME_PRESENCE_LISTEN_EVENTS;!function(REALTIME_PRESENCE_LISTEN_EVENTS){REALTIME_PRESENCE_LISTEN_EVENTS.SYNC="sync",REALTIME_PRESENCE_LISTEN_EVENTS.JOIN="join",REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE="leave"}(REALTIME_PRESENCE_LISTEN_EVENTS||(REALTIME_PRESENCE_LISTEN_EVENTS={}));class RealtimePresence{constructor(channel,opts){this.channel=channel,this.state={},this.pendingDiffs=[],this.joinRef=null,this.enabled=!1,this.caller={onJoin:()=>{},onLeave:()=>{},onSync:()=>{}};const events=(null==opts?void 0:opts.events)||{state:"presence_state",diff:"presence_diff"};this.channel._on(events.state,{},newState=>{const{onJoin,onLeave,onSync}=this.caller;this.joinRef=this.channel._joinRef(),this.state=RealtimePresence.syncState(this.state,newState,onJoin,onLeave),this.pendingDiffs.forEach(diff=>{this.state=RealtimePresence.syncDiff(this.state,diff,onJoin,onLeave)}),this.pendingDiffs=[],onSync()}),this.channel._on(events.diff,{},diff=>{const{onJoin,onLeave,onSync}=this.caller;this.inPendingSyncState()?this.pendingDiffs.push(diff):(this.state=RealtimePresence.syncDiff(this.state,diff,onJoin,onLeave),onSync())}),this.onJoin((key,currentPresences,newPresences)=>{this.channel._trigger("presence",{event:"join",key,currentPresences,newPresences})}),this.onLeave((key,currentPresences,leftPresences)=>{this.channel._trigger("presence",{event:"leave",key,currentPresences,leftPresences})}),this.onSync(()=>{this.channel._trigger("presence",{event:"sync"})})}static syncState(currentState,newState,onJoin,onLeave){const state=this.cloneDeep(currentState),transformedState=this.transformState(newState),joins={},leaves={};return this.map(state,(key,presences)=>{transformedState[key]||(leaves[key]=presences)}),this.map(transformedState,(key,newPresences)=>{const currentPresences=state[key];if(currentPresences){const newPresenceRefs=newPresences.map(m=>m.presence_ref),curPresenceRefs=currentPresences.map(m=>m.presence_ref),joinedPresences=newPresences.filter(m=>curPresenceRefs.indexOf(m.presence_ref)<0),leftPresences=currentPresences.filter(m=>newPresenceRefs.indexOf(m.presence_ref)<0);joinedPresences.length>0&&(joins[key]=joinedPresences),leftPresences.length>0&&(leaves[key]=leftPresences)}else joins[key]=newPresences}),this.syncDiff(state,{joins,leaves},onJoin,onLeave)}static syncDiff(state,diff,onJoin,onLeave){const{joins,leaves}={joins:this.transformState(diff.joins),leaves:this.transformState(diff.leaves)};return onJoin||(onJoin=()=>{}),onLeave||(onLeave=()=>{}),this.map(joins,(key,newPresences)=>{var _a;const currentPresences=null!==(_a=state[key])&&void 0!==_a?_a:[];if(state[key]=this.cloneDeep(newPresences),currentPresences.length>0){const joinedPresenceRefs=state[key].map(m=>m.presence_ref),curPresences=currentPresences.filter(m=>joinedPresenceRefs.indexOf(m.presence_ref)<0);state[key].unshift(...curPresences)}onJoin(key,currentPresences,newPresences)}),this.map(leaves,(key,leftPresences)=>{let currentPresences=state[key];if(!currentPresences)return;const presenceRefsToRemove=leftPresences.map(m=>m.presence_ref);currentPresences=currentPresences.filter(m=>presenceRefsToRemove.indexOf(m.presence_ref)<0),state[key]=currentPresences,onLeave(key,currentPresences,leftPresences),0===currentPresences.length&&delete state[key]}),state}static map(obj,func){return Object.getOwnPropertyNames(obj).map(key=>func(key,obj[key]))}static transformState(state){return state=this.cloneDeep(state),Object.getOwnPropertyNames(state).reduce((newState,key)=>{const presences=state[key];return newState[key]="metas"in presences?presences.metas.map(presence=>(presence.presence_ref=presence.phx_ref,delete presence.phx_ref,delete presence.phx_ref_prev,presence)):presences,newState},{})}static cloneDeep(obj){return JSON.parse(JSON.stringify(obj))}onJoin(callback){this.caller.onJoin=callback}onLeave(callback){this.caller.onLeave=callback}onSync(callback){this.caller.onSync=callback}inPendingSyncState(){return!this.joinRef||this.joinRef!==this.channel._joinRef()}}var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT,REALTIME_LISTEN_TYPES,REALTIME_SUBSCRIBE_STATES,RealtimeChannel_console=__webpack_require__("./node_modules/console-browserify/index.js");!function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT){REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL="*",REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT="INSERT",REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE="UPDATE",REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE="DELETE"}(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT||(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT={})),function(REALTIME_LISTEN_TYPES){REALTIME_LISTEN_TYPES.BROADCAST="broadcast",REALTIME_LISTEN_TYPES.PRESENCE="presence",REALTIME_LISTEN_TYPES.POSTGRES_CHANGES="postgres_changes",REALTIME_LISTEN_TYPES.SYSTEM="system"}(REALTIME_LISTEN_TYPES||(REALTIME_LISTEN_TYPES={})),function(REALTIME_SUBSCRIBE_STATES){REALTIME_SUBSCRIBE_STATES.SUBSCRIBED="SUBSCRIBED",REALTIME_SUBSCRIBE_STATES.TIMED_OUT="TIMED_OUT",REALTIME_SUBSCRIBE_STATES.CLOSED="CLOSED",REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR="CHANNEL_ERROR"}(REALTIME_SUBSCRIBE_STATES||(REALTIME_SUBSCRIBE_STATES={}));class RealtimeChannel{constructor(topic,params={config:{}},socket){var _a,_b;if(this.topic=topic,this.params=params,this.socket=socket,this.bindings={},this.state=constants_CHANNEL_STATES.closed,this.joinedOnce=!1,this.pushBuffer=[],this.subTopic=topic.replace(/^realtime:/i,""),this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:"",enabled:!1},private:!1},params.config),this.timeout=this.socket.timeout,this.joinPush=new Push(this,CHANNEL_EVENTS.join,this.params,this.timeout),this.rejoinTimer=new Timer(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive("ok",()=>{this.state=constants_CHANNEL_STATES.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(pushEvent=>pushEvent.send()),this.pushBuffer=[]}),this._onClose(()=>{this.rejoinTimer.reset(),this.socket.log("channel",`close ${this.topic} ${this._joinRef()}`),this.state=constants_CHANNEL_STATES.closed,this.socket._remove(this)}),this._onError(reason=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,reason),this.state=constants_CHANNEL_STATES.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("timeout",()=>{this._isJoining()&&(this.socket.log("channel",`timeout ${this.topic}`,this.joinPush.timeout),this.state=constants_CHANNEL_STATES.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("error",reason=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,reason),this.state=constants_CHANNEL_STATES.errored,this.rejoinTimer.scheduleTimeout())}),this._on(CHANNEL_EVENTS.reply,{},(payload,ref)=>{this._trigger(this._replyEventName(ref),payload)}),this.presence=new RealtimePresence(this),this.broadcastEndpointURL=httpEndpointURL(this.socket.endPoint),this.private=this.params.config.private||!1,!this.private&&(null===(_b=null===(_a=this.params.config)||void 0===_a?void 0:_a.broadcast)||void 0===_b?void 0:_b.replay))throw`tried to use replay on public channel '${this.topic}'. It must be a private channel.`}subscribe(callback,timeout=this.timeout){var _a,_b,_c;if(this.socket.isConnected()||this.socket.connect(),this.state==constants_CHANNEL_STATES.closed){const{config:{broadcast,presence,private:isPrivate}}=this.params,postgres_changes=null!==(_b=null===(_a=this.bindings.postgres_changes)||void 0===_a?void 0:_a.map(r=>r.filter))&&void 0!==_b?_b:[],presence_enabled=!!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE]&&this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length>0||!0===(null===(_c=this.params.config.presence)||void 0===_c?void 0:_c.enabled),accessTokenPayload={},config={broadcast,presence:Object.assign(Object.assign({},presence),{enabled:presence_enabled}),postgres_changes,private:isPrivate};this.socket.accessTokenValue&&(accessTokenPayload.access_token=this.socket.accessTokenValue),this._onError(e=>null==callback?void 0:callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,e)),this._onClose(()=>null==callback?void 0:callback(REALTIME_SUBSCRIBE_STATES.CLOSED)),this.updateJoinPayload(Object.assign({config},accessTokenPayload)),this.joinedOnce=!0,this._rejoin(timeout),this.joinPush.receive("ok",async({postgres_changes})=>{var _a;if(this.socket.setAuth(),void 0!==postgres_changes){const clientPostgresBindings=this.bindings.postgres_changes,bindingsLen=null!==(_a=null==clientPostgresBindings?void 0:clientPostgresBindings.length)&&void 0!==_a?_a:0,newPostgresBindings=[];for(let i=0;i<bindingsLen;i++){const clientPostgresBinding=clientPostgresBindings[i],{filter:{event,schema,table,filter}}=clientPostgresBinding,serverPostgresFilter=postgres_changes&&postgres_changes[i];if(!serverPostgresFilter||serverPostgresFilter.event!==event||serverPostgresFilter.schema!==schema||serverPostgresFilter.table!==table||serverPostgresFilter.filter!==filter)return this.unsubscribe(),this.state=constants_CHANNEL_STATES.errored,void(null==callback||callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,new Error("mismatch between server and client bindings for postgres changes")));newPostgresBindings.push(Object.assign(Object.assign({},clientPostgresBinding),{id:serverPostgresFilter.id}))}return this.bindings.postgres_changes=newPostgresBindings,void(callback&&callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED))}null==callback||callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED)}).receive("error",error=>{this.state=constants_CHANNEL_STATES.errored,null==callback||callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,new Error(JSON.stringify(Object.values(error).join(", ")||"error")))}).receive("timeout",()=>{null==callback||callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT)})}return this}presenceState(){return this.presence.state}async track(payload,opts={}){return await this.send({type:"presence",event:"track",payload},opts.timeout||this.timeout)}async untrack(opts={}){return await this.send({type:"presence",event:"untrack"},opts)}on(type,filter,callback){return this.state===constants_CHANNEL_STATES.joined&&type===REALTIME_LISTEN_TYPES.PRESENCE&&(this.socket.log("channel",`resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),this.unsubscribe().then(()=>this.subscribe())),this._on(type,filter,callback)}async httpSend(event,payload,opts={}){var _a;const authorization=this.socket.accessTokenValue?`Bearer ${this.socket.accessTokenValue}`:"";if(null==payload)return Promise.reject("Payload is required for httpSend()");const options={method:"POST",headers:{Authorization:authorization,apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"},body:JSON.stringify({messages:[{topic:this.subTopic,event,payload,private:this.private}]})},response=await this._fetchWithTimeout(this.broadcastEndpointURL,options,null!==(_a=opts.timeout)&&void 0!==_a?_a:this.timeout);if(202===response.status)return{success:!0};let errorMessage=response.statusText;try{const errorBody=await response.json();errorMessage=errorBody.error||errorBody.message||errorMessage}catch(_b){}return Promise.reject(new Error(errorMessage))}async send(args,opts={}){var _a,_b;if(this._canPush()||"broadcast"!==args.type)return new Promise(resolve=>{var _a,_b,_c;const push=this._push(args.type,args,opts.timeout||this.timeout);"broadcast"!==args.type||(null===(_c=null===(_b=null===(_a=this.params)||void 0===_a?void 0:_a.config)||void 0===_b?void 0:_b.broadcast)||void 0===_c?void 0:_c.ack)||resolve("ok"),push.receive("ok",()=>resolve("ok")),push.receive("error",()=>resolve("error")),push.receive("timeout",()=>resolve("timed out"))});{RealtimeChannel_console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");const{event,payload:endpoint_payload}=args,options={method:"POST",headers:{Authorization:this.socket.accessTokenValue?`Bearer ${this.socket.accessTokenValue}`:"",apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"},body:JSON.stringify({messages:[{topic:this.subTopic,event,payload:endpoint_payload,private:this.private}]})};try{const response=await this._fetchWithTimeout(this.broadcastEndpointURL,options,null!==(_a=opts.timeout)&&void 0!==_a?_a:this.timeout);return await(null===(_b=response.body)||void 0===_b?void 0:_b.cancel()),response.ok?"ok":"error"}catch(error){return"AbortError"===error.name?"timed out":"error"}}}updateJoinPayload(payload){this.joinPush.updatePayload(payload)}unsubscribe(timeout=this.timeout){this.state=constants_CHANNEL_STATES.leaving;const onClose=()=>{this.socket.log("channel",`leave ${this.topic}`),this._trigger(CHANNEL_EVENTS.close,"leave",this._joinRef())};this.joinPush.destroy();let leavePush=null;return new Promise(resolve=>{leavePush=new Push(this,CHANNEL_EVENTS.leave,{},timeout),leavePush.receive("ok",()=>{onClose(),resolve("ok")}).receive("timeout",()=>{onClose(),resolve("timed out")}).receive("error",()=>{resolve("error")}),leavePush.send(),this._canPush()||leavePush.trigger("ok",{})}).finally(()=>{null==leavePush||leavePush.destroy()})}teardown(){this.pushBuffer.forEach(push=>push.destroy()),this.pushBuffer=[],this.rejoinTimer.reset(),this.joinPush.destroy(),this.state=constants_CHANNEL_STATES.closed,this.bindings={}}async _fetchWithTimeout(url,options,timeout){const controller=new AbortController,id=setTimeout(()=>controller.abort(),timeout),response=await this.socket.fetch(url,Object.assign(Object.assign({},options),{signal:controller.signal}));return clearTimeout(id),response}_push(event,payload,timeout=this.timeout){if(!this.joinedOnce)throw`tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;let pushEvent=new Push(this,event,payload,timeout);return this._canPush()?pushEvent.send():this._addToPushBuffer(pushEvent),pushEvent}_addToPushBuffer(pushEvent){if(pushEvent.startTimeout(),this.pushBuffer.push(pushEvent),this.pushBuffer.length>100){const removedPush=this.pushBuffer.shift();removedPush&&(removedPush.destroy(),this.socket.log("channel",`discarded push due to buffer overflow: ${removedPush.event}`,removedPush.payload))}}_onMessage(_event,payload,_ref){return payload}_isMember(topic){return this.topic===topic}_joinRef(){return this.joinPush.ref}_trigger(type,payload,ref){var _a,_b;const typeLower=type.toLocaleLowerCase(),{close,error,leave,join}=CHANNEL_EVENTS;if(ref&&[close,error,leave,join].indexOf(typeLower)>=0&&ref!==this._joinRef())return;let handledPayload=this._onMessage(typeLower,payload,ref);if(payload&&!handledPayload)throw"channel onMessage callbacks must return the payload, modified or unmodified";["insert","update","delete"].includes(typeLower)?null===(_a=this.bindings.postgres_changes)||void 0===_a||_a.filter(bind=>{var _a,_b,_c;return"*"===(null===(_a=bind.filter)||void 0===_a?void 0:_a.event)||(null===(_c=null===(_b=bind.filter)||void 0===_b?void 0:_b.event)||void 0===_c?void 0:_c.toLocaleLowerCase())===typeLower}).map(bind=>bind.callback(handledPayload,ref)):null===(_b=this.bindings[typeLower])||void 0===_b||_b.filter(bind=>{var _a,_b,_c,_d,_e,_f;if(["broadcast","presence","postgres_changes"].includes(typeLower)){if("id"in bind){const bindId=bind.id,bindEvent=null===(_a=bind.filter)||void 0===_a?void 0:_a.event;return bindId&&(null===(_b=payload.ids)||void 0===_b?void 0:_b.includes(bindId))&&("*"===bindEvent||(null==bindEvent?void 0:bindEvent.toLocaleLowerCase())===(null===(_c=payload.data)||void 0===_c?void 0:_c.type.toLocaleLowerCase()))}{const bindEvent=null===(_e=null===(_d=null==bind?void 0:bind.filter)||void 0===_d?void 0:_d.event)||void 0===_e?void 0:_e.toLocaleLowerCase();return"*"===bindEvent||bindEvent===(null===(_f=null==payload?void 0:payload.event)||void 0===_f?void 0:_f.toLocaleLowerCase())}}return bind.type.toLocaleLowerCase()===typeLower}).map(bind=>{if("object"==typeof handledPayload&&"ids"in handledPayload){const postgresChanges=handledPayload.data,{schema,table,commit_timestamp,type,errors}=postgresChanges,enrichedPayload={schema,table,commit_timestamp,eventType:type,new:{},old:{},errors};handledPayload=Object.assign(Object.assign({},enrichedPayload),this._getPayloadRecords(postgresChanges))}bind.callback(handledPayload,ref)})}_isClosed(){return this.state===constants_CHANNEL_STATES.closed}_isJoined(){return this.state===constants_CHANNEL_STATES.joined}_isJoining(){return this.state===constants_CHANNEL_STATES.joining}_isLeaving(){return this.state===constants_CHANNEL_STATES.leaving}_replyEventName(ref){return`chan_reply_${ref}`}_on(type,filter,callback){const typeLower=type.toLocaleLowerCase(),binding={type:typeLower,filter,callback};return this.bindings[typeLower]?this.bindings[typeLower].push(binding):this.bindings[typeLower]=[binding],this}_off(type,filter){const typeLower=type.toLocaleLowerCase();return this.bindings[typeLower]&&(this.bindings[typeLower]=this.bindings[typeLower].filter(bind=>{var _a;return!((null===(_a=bind.type)||void 0===_a?void 0:_a.toLocaleLowerCase())===typeLower&&RealtimeChannel.isEqual(bind.filter,filter))})),this}static isEqual(obj1,obj2){if(Object.keys(obj1).length!==Object.keys(obj2).length)return!1;for(const k in obj1)if(obj1[k]!==obj2[k])return!1;return!0}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout(),this.socket.isConnected()&&this._rejoin()}_onClose(callback){this._on(CHANNEL_EVENTS.close,{},callback)}_onError(callback){this._on(CHANNEL_EVENTS.error,{},reason=>callback(reason))}_canPush(){return this.socket.isConnected()&&this._isJoined()}_rejoin(timeout=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=constants_CHANNEL_STATES.joining,this.joinPush.resend(timeout))}_getPayloadRecords(payload){const records={new:{},old:{}};return"INSERT"!==payload.type&&"UPDATE"!==payload.type||(records.new=convertChangeData(payload.columns,payload.record)),"UPDATE"!==payload.type&&"DELETE"!==payload.type||(records.old=convertChangeData(payload.columns,payload.old_record)),records}}const RealtimeClient_noop=()=>{},CONNECTION_TIMEOUTS_HEARTBEAT_INTERVAL=25e3,CONNECTION_TIMEOUTS_RECONNECT_DELAY=10,CONNECTION_TIMEOUTS_HEARTBEAT_TIMEOUT_FALLBACK=100,RECONNECT_INTERVALS=[1e3,2e3,5e3,1e4];class RealtimeClient{constructor(endPoint,options){var _a;if(this.accessTokenValue=null,this.apiKey=null,this.channels=new Array,this.endPoint="",this.httpEndpoint="",this.headers={},this.params={},this.timeout=1e4,this.transport=null,this.heartbeatIntervalMs=CONNECTION_TIMEOUTS_HEARTBEAT_INTERVAL,this.heartbeatTimer=void 0,this.pendingHeartbeatRef=null,this.heartbeatCallback=RealtimeClient_noop,this.ref=0,this.reconnectTimer=null,this.logger=RealtimeClient_noop,this.conn=null,this.sendBuffer=[],this.serializer=new Serializer,this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.accessToken=null,this._connectionState="disconnected",this._wasManualDisconnect=!1,this._authPromise=null,this._resolveFetch=customFetch=>customFetch?(...args)=>customFetch(...args):(...args)=>fetch(...args),!(null===(_a=null==options?void 0:options.params)||void 0===_a?void 0:_a.apikey))throw new Error("API key is required to connect to Realtime");this.apiKey=options.params.apikey,this.endPoint=`${endPoint}/${TRANSPORTS.websocket}`,this.httpEndpoint=httpEndpointURL(endPoint),this._initializeOptions(options),this._setupReconnectionTimer(),this.fetch=this._resolveFetch(null==options?void 0:options.fetch)}connect(){if(!(this.isConnecting()||this.isDisconnecting()||null!==this.conn&&this.isConnected())){if(this._setConnectionState("connecting"),this._setAuthSafely("connect"),this.transport)this.conn=new this.transport(this.endpointURL());else try{this.conn=websocket_factory.createWebSocket(this.endpointURL())}catch(error){this._setConnectionState("disconnected");const errorMessage=error.message;if(errorMessage.includes("Node.js"))throw new Error(`${errorMessage}\n\nTo use Realtime in Node.js, you need to provide a WebSocket implementation:\n\nOption 1: Use Node.js 22+ which has native WebSocket support\nOption 2: Install and provide the "ws" package:\n\n  npm install ws\n\n  import ws from "ws"\n  const client = new RealtimeClient(url, {\n    ...options,\n    transport: ws\n  })`);throw new Error(`WebSocket not available: ${errorMessage}`)}this._setupConnectionHandlers()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:"1.0.0"}))}disconnect(code,reason){if(!this.isDisconnecting())if(this._setConnectionState("disconnecting",!0),this.conn){const fallbackTimer=setTimeout(()=>{this._setConnectionState("disconnected")},100);this.conn.onclose=()=>{clearTimeout(fallbackTimer),this._setConnectionState("disconnected")},code?this.conn.close(code,null!=reason?reason:""):this.conn.close(),this._teardownConnection()}else this._setConnectionState("disconnected")}getChannels(){return this.channels}async removeChannel(channel){const status=await channel.unsubscribe();return 0===this.channels.length&&this.disconnect(),status}async removeAllChannels(){const values_1=await Promise.all(this.channels.map(channel=>channel.unsubscribe()));return this.channels=[],this.disconnect(),values_1}log(kind,msg,data){this.logger(kind,msg,data)}connectionState(){switch(this.conn&&this.conn.readyState){case SOCKET_STATES.connecting:return CONNECTION_STATE.Connecting;case SOCKET_STATES.open:return CONNECTION_STATE.Open;case SOCKET_STATES.closing:return CONNECTION_STATE.Closing;default:return CONNECTION_STATE.Closed}}isConnected(){return this.connectionState()===CONNECTION_STATE.Open}isConnecting(){return"connecting"===this._connectionState}isDisconnecting(){return"disconnecting"===this._connectionState}channel(topic,params={config:{}}){const realtimeTopic=`realtime:${topic}`,exists=this.getChannels().find(c=>c.topic===realtimeTopic);if(exists)return exists;{const chan=new RealtimeChannel(`realtime:${topic}`,params,this);return this.channels.push(chan),chan}}push(data){const{topic,event,payload,ref}=data,callback=()=>{this.encode(data,result=>{var _a;null===(_a=this.conn)||void 0===_a||_a.send(result)})};this.log("push",`${topic} ${event} (${ref})`,payload),this.isConnected()?callback():this.sendBuffer.push(callback)}async setAuth(token=null){this._authPromise=this._performAuth(token);try{await this._authPromise}finally{this._authPromise=null}}async sendHeartbeat(){var _a;if(this.isConnected()){if(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null,this.log("transport","heartbeat timeout. Attempting to re-establish connection");try{this.heartbeatCallback("timeout")}catch(e){this.log("error","error in heartbeat callback",e)}return this._wasManualDisconnect=!1,null===(_a=this.conn)||void 0===_a||_a.close(1e3,"heartbeat timeout"),void setTimeout(()=>{var _a;this.isConnected()||null===(_a=this.reconnectTimer)||void 0===_a||_a.scheduleTimeout()},CONNECTION_TIMEOUTS_HEARTBEAT_TIMEOUT_FALLBACK)}this.pendingHeartbeatRef=this._makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef});try{this.heartbeatCallback("sent")}catch(e){this.log("error","error in heartbeat callback",e)}this._setAuthSafely("heartbeat")}else try{this.heartbeatCallback("disconnected")}catch(e){this.log("error","error in heartbeat callback",e)}}onHeartbeat(callback){this.heartbeatCallback=callback}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(callback=>callback()),this.sendBuffer=[])}_makeRef(){let newRef=this.ref+1;return newRef===this.ref?this.ref=0:this.ref=newRef,this.ref.toString()}_leaveOpenTopic(topic){let dupChannel=this.channels.find(c=>c.topic===topic&&(c._isJoined()||c._isJoining()));dupChannel&&(this.log("transport",`leaving duplicate topic "${topic}"`),dupChannel.unsubscribe())}_remove(channel){this.channels=this.channels.filter(c=>c.topic!==channel.topic)}_onConnMessage(rawMessage){this.decode(rawMessage.data,msg=>{if("phoenix"===msg.topic&&"phx_reply"===msg.event)try{this.heartbeatCallback("ok"===msg.payload.status?"ok":"error")}catch(e){this.log("error","error in heartbeat callback",e)}msg.ref&&msg.ref===this.pendingHeartbeatRef&&(this.pendingHeartbeatRef=null);const{topic,event,payload,ref}=msg,refString=ref?`(${ref})`:"",status=payload.status||"";this.log("receive",`${status} ${topic} ${event} ${refString}`.trim(),payload),this.channels.filter(channel=>channel._isMember(topic)).forEach(channel=>channel._trigger(event,payload,ref)),this._triggerStateCallbacks("message",msg)})}_clearTimer(timer){var _a;"heartbeat"===timer&&this.heartbeatTimer?(clearInterval(this.heartbeatTimer),this.heartbeatTimer=void 0):"reconnect"===timer&&(null===(_a=this.reconnectTimer)||void 0===_a||_a.reset())}_clearAllTimers(){this._clearTimer("heartbeat"),this._clearTimer("reconnect")}_setupConnectionHandlers(){this.conn&&("binaryType"in this.conn&&(this.conn.binaryType="arraybuffer"),this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=error=>this._onConnError(error),this.conn.onmessage=event=>this._onConnMessage(event),this.conn.onclose=event=>this._onConnClose(event))}_teardownConnection(){this.conn&&(this.conn.onopen=null,this.conn.onerror=null,this.conn.onmessage=null,this.conn.onclose=null,this.conn=null),this._clearAllTimers(),this.channels.forEach(channel=>channel.teardown())}_onConnOpen(){this._setConnectionState("connected"),this.log("transport",`connected to ${this.endpointURL()}`),this.flushSendBuffer(),this._clearTimer("reconnect"),this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat(),this._triggerStateCallbacks("open")}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?this.log("worker",`starting worker for from ${this.workerUrl}`):this.log("worker","starting default worker");const objectUrl=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(objectUrl),this.workerRef.onerror=error=>{this.log("worker","worker error",error.message),this.workerRef.terminate()},this.workerRef.onmessage=event=>{"keepAlive"===event.data.event&&this.sendHeartbeat()},this.workerRef.postMessage({event:"start",interval:this.heartbeatIntervalMs})}_onConnClose(event){var _a;this._setConnectionState("disconnected"),this.log("transport","close",event),this._triggerChanError(),this._clearTimer("heartbeat"),this._wasManualDisconnect||null===(_a=this.reconnectTimer)||void 0===_a||_a.scheduleTimeout(),this._triggerStateCallbacks("close",event)}_onConnError(error){this._setConnectionState("disconnected"),this.log("transport",`${error}`),this._triggerChanError(),this._triggerStateCallbacks("error",error)}_triggerChanError(){this.channels.forEach(channel=>channel._trigger(CHANNEL_EVENTS.error))}_appendParams(url,params){if(0===Object.keys(params).length)return url;const prefix=url.match(/\?/)?"&":"?";return`${url}${prefix}${new URLSearchParams(params)}`}_workerObjectUrl(url){let result_url;if(url)result_url=url;else{const blob=new Blob(['\n  addEventListener("message", (e) => {\n    if (e.data.event === "start") {\n      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);\n    }\n  });'],{type:"application/javascript"});result_url=URL.createObjectURL(blob)}return result_url}_setConnectionState(state,manual=!1){this._connectionState=state,"connecting"===state?this._wasManualDisconnect=!1:"disconnecting"===state&&(this._wasManualDisconnect=manual)}async _performAuth(token=null){let tokenToSend;tokenToSend=token||(this.accessToken?await this.accessToken():this.accessTokenValue),this.accessTokenValue!=tokenToSend&&(this.accessTokenValue=tokenToSend,this.channels.forEach(channel=>{const payload={access_token:tokenToSend,version:"realtime-js/2.79.0"};tokenToSend&&channel.updateJoinPayload(payload),channel.joinedOnce&&channel._isJoined()&&channel._push(CHANNEL_EVENTS.access_token,{access_token:tokenToSend})}))}async _waitForAuthIfNeeded(){this._authPromise&&await this._authPromise}_setAuthSafely(context="general"){this.setAuth().catch(e=>{this.log("error",`error setting auth in ${context}`,e)})}_triggerStateCallbacks(event,data){try{this.stateChangeCallbacks[event].forEach(callback=>{try{callback(data)}catch(e){this.log("error",`error in ${event} callback`,e)}})}catch(e){this.log("error",`error triggering ${event} callbacks`,e)}}_setupReconnectionTimer(){this.reconnectTimer=new Timer(async()=>{setTimeout(async()=>{await this._waitForAuthIfNeeded(),this.isConnected()||this.connect()},CONNECTION_TIMEOUTS_RECONNECT_DELAY)},this.reconnectAfterMs)}_initializeOptions(options){var _a,_b,_c,_d,_e,_f,_g,_h,_j;if(this.transport=null!==(_a=null==options?void 0:options.transport)&&void 0!==_a?_a:null,this.timeout=null!==(_b=null==options?void 0:options.timeout)&&void 0!==_b?_b:1e4,this.heartbeatIntervalMs=null!==(_c=null==options?void 0:options.heartbeatIntervalMs)&&void 0!==_c?_c:CONNECTION_TIMEOUTS_HEARTBEAT_INTERVAL,this.worker=null!==(_d=null==options?void 0:options.worker)&&void 0!==_d&&_d,this.accessToken=null!==(_e=null==options?void 0:options.accessToken)&&void 0!==_e?_e:null,this.heartbeatCallback=null!==(_f=null==options?void 0:options.heartbeatCallback)&&void 0!==_f?_f:RealtimeClient_noop,(null==options?void 0:options.params)&&(this.params=options.params),(null==options?void 0:options.logger)&&(this.logger=options.logger),((null==options?void 0:options.logLevel)||(null==options?void 0:options.log_level))&&(this.logLevel=options.logLevel||options.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel})),this.reconnectAfterMs=null!==(_g=null==options?void 0:options.reconnectAfterMs)&&void 0!==_g?_g:tries=>RECONNECT_INTERVALS[tries-1]||1e4,this.encode=null!==(_h=null==options?void 0:options.encode)&&void 0!==_h?_h:(payload,callback)=>callback(JSON.stringify(payload)),this.decode=null!==(_j=null==options?void 0:options.decode)&&void 0!==_j?_j:this.serializer.decode.bind(this.serializer),this.worker){if("undefined"!=typeof window&&!window.Worker)throw new Error("Web Worker is not supported");this.workerUrl=null==options?void 0:options.workerUrl}}}class StorageError extends Error{constructor(message){super(message),this.__isStorageError=!0,this.name="StorageError"}}function isStorageError(error){return"object"==typeof error&&null!==error&&"__isStorageError"in error}class StorageApiError extends StorageError{constructor(message,status,statusCode){super(message),this.name="StorageApiError",this.status=status,this.statusCode=statusCode}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}}class StorageUnknownError extends StorageError{constructor(message,originalError){super(message),this.name="StorageUnknownError",this.originalError=originalError}}const helpers_resolveFetch=customFetch=>customFetch?(...args)=>customFetch(...args):(...args)=>fetch(...args),recursiveToCamel=item=>{if(Array.isArray(item))return item.map(el=>recursiveToCamel(el));if("function"==typeof item||item!==Object(item))return item;const result={};return Object.entries(item).forEach(([key,value])=>{const newKey=key.replace(/([-_][a-z])/gi,c=>c.toUpperCase().replace(/[-_]/g,""));result[newKey]=recursiveToCamel(value)}),result},_getErrorMessage=err=>{var _a;return err.msg||err.message||err.error_description||("string"==typeof err.error?err.error:null===(_a=err.error)||void 0===_a?void 0:_a.message)||JSON.stringify(err)},handleError=(error,reject,options)=>(0,tslib_es6.__awaiter)(void 0,void 0,void 0,function*(){const Res=yield Response;error instanceof Res&&!(null==options?void 0:options.noResolveJson)?error.json().then(err=>{const status=error.status||500,statusCode=(null==err?void 0:err.statusCode)||status+"";reject(new StorageApiError(_getErrorMessage(err),status,statusCode))}).catch(err=>{reject(new StorageUnknownError(_getErrorMessage(err),err))}):reject(new StorageUnknownError(_getErrorMessage(error),error))}),_getRequestParams=(method,options,parameters,body)=>{const params={method,headers:(null==options?void 0:options.headers)||{}};return"GET"!==method&&body?((value=>{if("object"!=typeof value||null===value)return!1;const prototype=Object.getPrototypeOf(value);return!(null!==prototype&&prototype!==Object.prototype&&null!==Object.getPrototypeOf(prototype)||Symbol.toStringTag in value||Symbol.iterator in value)})(body)?(params.headers=Object.assign({"Content-Type":"application/json"},null==options?void 0:options.headers),params.body=JSON.stringify(body)):params.body=body,(null==options?void 0:options.duplex)&&(params.duplex=options.duplex),Object.assign(Object.assign({},params),parameters)):params};function _handleRequest(fetcher,method,url,options,parameters,body){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return new Promise((resolve,reject)=>{fetcher(url,_getRequestParams(method,options,parameters,body)).then(result=>{if(!result.ok)throw result;return(null==options?void 0:options.noResolveJson)?result:result.json()}).then(data=>resolve(data)).catch(error=>handleError(error,reject,options))})})}function get(fetcher,url,options,parameters){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return _handleRequest(fetcher,"GET",url,options,parameters)})}function post(fetcher,url,body,options,parameters){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return _handleRequest(fetcher,"POST",url,options,parameters,body)})}function put(fetcher,url,body,options,parameters){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return _handleRequest(fetcher,"PUT",url,options,parameters,body)})}function remove(fetcher,url,body,options,parameters){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return _handleRequest(fetcher,"DELETE",url,options,parameters,body)})}class StreamDownloadBuilder{constructor(downloadFn,shouldThrowOnError){this.downloadFn=downloadFn,this.shouldThrowOnError=shouldThrowOnError}then(onfulfilled,onrejected){return this.execute().then(onfulfilled,onrejected)}execute(){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:(yield this.downloadFn()).body,error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}}var _a;_a=Symbol.toStringTag;const packages_BlobDownloadBuilder=class BlobDownloadBuilder{constructor(downloadFn,shouldThrowOnError){this.downloadFn=downloadFn,this.shouldThrowOnError=shouldThrowOnError,this[_a]="BlobDownloadBuilder",this.promise=null}asStream(){return new StreamDownloadBuilder(this.downloadFn,this.shouldThrowOnError)}then(onfulfilled,onrejected){return this.getPromise().then(onfulfilled,onrejected)}catch(onrejected){return this.getPromise().catch(onrejected)}finally(onfinally){return this.getPromise().finally(onfinally)}getPromise(){return this.promise||(this.promise=this.execute()),this.promise}execute(){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{const result=yield this.downloadFn();return{data:yield result.blob(),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}};var Buffer=__webpack_require__("./node_modules/buffer/index.js").Buffer;const DEFAULT_SEARCH_OPTIONS={limit:100,offset:0,sortBy:{column:"name",order:"asc"}},DEFAULT_FILE_OPTIONS={cacheControl:"3600",contentType:"text/plain;charset=UTF-8",upsert:!1};class StorageFileApi{constructor(url,headers={},bucketId,fetch){this.shouldThrowOnError=!1,this.url=url,this.headers=headers,this.bucketId=bucketId,this.fetch=helpers_resolveFetch(fetch)}throwOnError(){return this.shouldThrowOnError=!0,this}uploadOrUpdate(method,path,fileBody,fileOptions){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{let body;const options=Object.assign(Object.assign({},DEFAULT_FILE_OPTIONS),fileOptions);let headers=Object.assign(Object.assign({},this.headers),"POST"===method&&{"x-upsert":String(options.upsert)});const metadata=options.metadata;if("undefined"!=typeof Blob&&fileBody instanceof Blob)body=new FormData,body.append("cacheControl",options.cacheControl),metadata&&body.append("metadata",this.encodeMetadata(metadata)),body.append("",fileBody);else if("undefined"!=typeof FormData&&fileBody instanceof FormData)body=fileBody,body.has("cacheControl")||body.append("cacheControl",options.cacheControl),metadata&&!body.has("metadata")&&body.append("metadata",this.encodeMetadata(metadata));else{body=fileBody,headers["cache-control"]=`max-age=${options.cacheControl}`,headers["content-type"]=options.contentType,metadata&&(headers["x-metadata"]=this.toBase64(this.encodeMetadata(metadata)));("undefined"!=typeof ReadableStream&&body instanceof ReadableStream||body&&"object"==typeof body&&"pipe"in body&&"function"==typeof body.pipe)&&!options.duplex&&(options.duplex="half")}(null==fileOptions?void 0:fileOptions.headers)&&(headers=Object.assign(Object.assign({},headers),fileOptions.headers));const cleanPath=this._removeEmptyFolders(path),_path=this._getFinalPath(cleanPath),data=yield("PUT"==method?put:post)(this.fetch,`${this.url}/object/${_path}`,body,Object.assign({headers},(null==options?void 0:options.duplex)?{duplex:options.duplex}:{}));return{data:{path:cleanPath,id:data.Id,fullPath:data.Key},error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}upload(path,fileBody,fileOptions){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return this.uploadOrUpdate("POST",path,fileBody,fileOptions)})}uploadToSignedUrl(path,token,fileBody,fileOptions){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){const cleanPath=this._removeEmptyFolders(path),_path=this._getFinalPath(cleanPath),url=new URL(this.url+`/object/upload/sign/${_path}`);url.searchParams.set("token",token);try{let body;const options=Object.assign({upsert:DEFAULT_FILE_OPTIONS.upsert},fileOptions),headers=Object.assign(Object.assign({},this.headers),{"x-upsert":String(options.upsert)});"undefined"!=typeof Blob&&fileBody instanceof Blob?(body=new FormData,body.append("cacheControl",options.cacheControl),body.append("",fileBody)):"undefined"!=typeof FormData&&fileBody instanceof FormData?(body=fileBody,body.append("cacheControl",options.cacheControl)):(body=fileBody,headers["cache-control"]=`max-age=${options.cacheControl}`,headers["content-type"]=options.contentType);return{data:{path:cleanPath,fullPath:(yield put(this.fetch,url.toString(),body,{headers})).Key},error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}createSignedUploadUrl(path,options){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{let _path=this._getFinalPath(path);const headers=Object.assign({},this.headers);(null==options?void 0:options.upsert)&&(headers["x-upsert"]="true");const data=yield post(this.fetch,`${this.url}/object/upload/sign/${_path}`,{},{headers}),url=new URL(this.url+data.url),token=url.searchParams.get("token");if(!token)throw new StorageError("No token returned by API");return{data:{signedUrl:url.toString(),path,token},error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}update(path,fileBody,fileOptions){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return this.uploadOrUpdate("PUT",path,fileBody,fileOptions)})}move(fromPath,toPath,options){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:yield post(this.fetch,`${this.url}/object/move`,{bucketId:this.bucketId,sourceKey:fromPath,destinationKey:toPath,destinationBucket:null==options?void 0:options.destinationBucket},{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}copy(fromPath,toPath,options){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:{path:(yield post(this.fetch,`${this.url}/object/copy`,{bucketId:this.bucketId,sourceKey:fromPath,destinationKey:toPath,destinationBucket:null==options?void 0:options.destinationBucket},{headers:this.headers})).Key},error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}createSignedUrl(path,expiresIn,options){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{let _path=this._getFinalPath(path),data=yield post(this.fetch,`${this.url}/object/sign/${_path}`,Object.assign({expiresIn},(null==options?void 0:options.transform)?{transform:options.transform}:{}),{headers:this.headers});const downloadQueryParam=(null==options?void 0:options.download)?`&download=${!0===options.download?"":options.download}`:"";return data={signedUrl:encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`)},{data,error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}createSignedUrls(paths,expiresIn,options){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{const data=yield post(this.fetch,`${this.url}/object/sign/${this.bucketId}`,{expiresIn,paths},{headers:this.headers}),downloadQueryParam=(null==options?void 0:options.download)?`&download=${!0===options.download?"":options.download}`:"";return{data:data.map(datum=>Object.assign(Object.assign({},datum),{signedUrl:datum.signedURL?encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`):null})),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}download(path,options){const renderPath=void 0!==(null==options?void 0:options.transform)?"render/image/authenticated":"object",transformationQuery=this.transformOptsToQueryString((null==options?void 0:options.transform)||{}),queryString=transformationQuery?`?${transformationQuery}`:"",_path=this._getFinalPath(path);return new packages_BlobDownloadBuilder(()=>get(this.fetch,`${this.url}/${renderPath}/${_path}${queryString}`,{headers:this.headers,noResolveJson:!0}),this.shouldThrowOnError)}info(path){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){const _path=this._getFinalPath(path);try{const data=yield get(this.fetch,`${this.url}/object/info/${_path}`,{headers:this.headers});return{data:recursiveToCamel(data),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}exists(path){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){const _path=this._getFinalPath(path);try{return yield function head(fetcher,url,options,parameters){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return _handleRequest(fetcher,"HEAD",url,Object.assign(Object.assign({},options),{noResolveJson:!0}),parameters)})}(this.fetch,`${this.url}/object/${_path}`,{headers:this.headers}),{data:!0,error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error)&&error instanceof StorageUnknownError){const originalError=error.originalError;if([400,404].includes(null==originalError?void 0:originalError.status))return{data:!1,error}}throw error}})}getPublicUrl(path,options){const _path=this._getFinalPath(path),_queryString=[],downloadQueryParam=(null==options?void 0:options.download)?`download=${!0===options.download?"":options.download}`:"";""!==downloadQueryParam&&_queryString.push(downloadQueryParam);const renderPath=void 0!==(null==options?void 0:options.transform)?"render/image":"object",transformationQuery=this.transformOptsToQueryString((null==options?void 0:options.transform)||{});""!==transformationQuery&&_queryString.push(transformationQuery);let queryString=_queryString.join("&");return""!==queryString&&(queryString=`?${queryString}`),{data:{publicUrl:encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`)}}}remove(paths){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:yield remove(this.fetch,`${this.url}/object/${this.bucketId}`,{prefixes:paths},{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}list(path,options,parameters){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{const body=Object.assign(Object.assign(Object.assign({},DEFAULT_SEARCH_OPTIONS),options),{prefix:path||""});return{data:yield post(this.fetch,`${this.url}/object/list/${this.bucketId}`,body,{headers:this.headers},parameters),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}listV2(options,parameters){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{const body=Object.assign({},options);return{data:yield post(this.fetch,`${this.url}/object/list-v2/${this.bucketId}`,body,{headers:this.headers},parameters),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}encodeMetadata(metadata){return JSON.stringify(metadata)}toBase64(data){return void 0!==Buffer?Buffer.from(data).toString("base64"):btoa(data)}_getFinalPath(path){return`${this.bucketId}/${path.replace(/^\/+/,"")}`}_removeEmptyFolders(path){return path.replace(/^\/|\/$/g,"").replace(/\/+/g,"/")}transformOptsToQueryString(transform){const params=[];return transform.width&&params.push(`width=${transform.width}`),transform.height&&params.push(`height=${transform.height}`),transform.resize&&params.push(`resize=${transform.resize}`),transform.format&&params.push(`format=${transform.format}`),transform.quality&&params.push(`quality=${transform.quality}`),params.join("&")}}const DEFAULT_HEADERS={"X-Client-Info":"storage-js/2.79.0"};class StorageBucketApi{constructor(url,headers={},fetch,opts){this.shouldThrowOnError=!1;const baseUrl=new URL(url);if(null==opts?void 0:opts.useNewHostname){/supabase\.(co|in|red)$/.test(baseUrl.hostname)&&!baseUrl.hostname.includes("storage.supabase.")&&(baseUrl.hostname=baseUrl.hostname.replace("supabase.","storage.supabase."))}this.url=baseUrl.href.replace(/\/$/,""),this.headers=Object.assign(Object.assign({},DEFAULT_HEADERS),headers),this.fetch=helpers_resolveFetch(fetch)}throwOnError(){return this.shouldThrowOnError=!0,this}listBuckets(options){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{const queryString=this.listBucketOptionsToQueryString(options);return{data:yield get(this.fetch,`${this.url}/bucket${queryString}`,{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}getBucket(id){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:yield get(this.fetch,`${this.url}/bucket/${id}`,{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}createBucket(id_1){return(0,tslib_es6.__awaiter)(this,arguments,void 0,function*(id,options={public:!1}){try{return{data:yield post(this.fetch,`${this.url}/bucket`,{id,name:id,type:options.type,public:options.public,file_size_limit:options.fileSizeLimit,allowed_mime_types:options.allowedMimeTypes},{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}updateBucket(id,options){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:yield put(this.fetch,`${this.url}/bucket/${id}`,{id,name:id,public:options.public,file_size_limit:options.fileSizeLimit,allowed_mime_types:options.allowedMimeTypes},{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}emptyBucket(id){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:yield post(this.fetch,`${this.url}/bucket/${id}/empty`,{},{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}deleteBucket(id){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:yield remove(this.fetch,`${this.url}/bucket/${id}`,{},{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}listBucketOptionsToQueryString(options){const params={};return options&&("limit"in options&&(params.limit=String(options.limit)),"offset"in options&&(params.offset=String(options.offset)),options.search&&(params.search=options.search),options.sortColumn&&(params.sortColumn=options.sortColumn),options.sortOrder&&(params.sortOrder=options.sortOrder)),Object.keys(params).length>0?"?"+new URLSearchParams(params).toString():""}}class StorageAnalyticsApi{constructor(url,headers={},fetch){this.shouldThrowOnError=!1,this.url=url.replace(/\/$/,""),this.headers=Object.assign(Object.assign({},DEFAULT_HEADERS),headers),this.fetch=helpers_resolveFetch(fetch)}throwOnError(){return this.shouldThrowOnError=!0,this}createBucket(name){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:yield post(this.fetch,`${this.url}/bucket`,{name},{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}listBuckets(options){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{const queryParams=new URLSearchParams;void 0!==(null==options?void 0:options.limit)&&queryParams.set("limit",options.limit.toString()),void 0!==(null==options?void 0:options.offset)&&queryParams.set("offset",options.offset.toString()),(null==options?void 0:options.sortColumn)&&queryParams.set("sortColumn",options.sortColumn),(null==options?void 0:options.sortOrder)&&queryParams.set("sortOrder",options.sortOrder),(null==options?void 0:options.search)&&queryParams.set("search",options.search);const queryString=queryParams.toString(),url=queryString?`${this.url}/bucket?${queryString}`:`${this.url}/bucket`;return{data:yield get(this.fetch,url,{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}deleteBucket(bucketId){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:yield remove(this.fetch,`${this.url}/bucket/${bucketId}`,{},{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageError(error))return{data:null,error};throw error}})}}const constants_DEFAULT_HEADERS={"X-Client-Info":"storage-js/2.79.0","Content-Type":"application/json"};class StorageVectorsError extends Error{constructor(message){super(message),this.__isStorageVectorsError=!0,this.name="StorageVectorsError"}}function isStorageVectorsError(error){return"object"==typeof error&&null!==error&&"__isStorageVectorsError"in error}class StorageVectorsApiError extends StorageVectorsError{constructor(message,status,statusCode){super(message),this.name="StorageVectorsApiError",this.status=status,this.statusCode=statusCode}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}}class StorageVectorsUnknownError extends StorageVectorsError{constructor(message,originalError){super(message),this.name="StorageVectorsUnknownError",this.originalError=originalError}}var StorageVectorsErrorCode;!function(StorageVectorsErrorCode){StorageVectorsErrorCode.InternalError="InternalError",StorageVectorsErrorCode.S3VectorConflictException="S3VectorConflictException",StorageVectorsErrorCode.S3VectorNotFoundException="S3VectorNotFoundException",StorageVectorsErrorCode.S3VectorBucketNotEmpty="S3VectorBucketNotEmpty",StorageVectorsErrorCode.S3VectorMaxBucketsExceeded="S3VectorMaxBucketsExceeded",StorageVectorsErrorCode.S3VectorMaxIndexesExceeded="S3VectorMaxIndexesExceeded"}(StorageVectorsErrorCode||(StorageVectorsErrorCode={}));const vectors_helpers_resolveFetch=customFetch=>customFetch?(...args)=>customFetch(...args):(...args)=>fetch(...args),fetch_getErrorMessage=err=>err.msg||err.message||err.error_description||err.error||JSON.stringify(err),fetch_getRequestParams=(method,options,parameters,body)=>{const params={method,headers:(null==options?void 0:options.headers)||{}};return"GET"!==method&&body?((value=>{if("object"!=typeof value||null===value)return!1;const prototype=Object.getPrototypeOf(value);return!(null!==prototype&&prototype!==Object.prototype&&null!==Object.getPrototypeOf(prototype)||Symbol.toStringTag in value||Symbol.iterator in value)})(body)?(params.headers=Object.assign({"Content-Type":"application/json"},null==options?void 0:options.headers),params.body=JSON.stringify(body)):params.body=body,Object.assign(Object.assign({},params),parameters)):params};function fetch_handleRequest(fetcher,method,url,options,parameters,body){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return new Promise((resolve,reject)=>{fetcher(url,fetch_getRequestParams(method,options,parameters,body)).then(result=>{if(!result.ok)throw result;if(null==options?void 0:options.noResolveJson)return result;const contentType=result.headers.get("content-type");return contentType&&contentType.includes("application/json")?result.json():{}}).then(data=>resolve(data)).catch(error=>((error,reject,options)=>(0,tslib_es6.__awaiter)(void 0,void 0,void 0,function*(){if(error&&"object"==typeof error&&"status"in error&&"ok"in error&&"number"==typeof error.status&&!(null==options?void 0:options.noResolveJson)){const status=error.status||500,responseError=error;if("function"==typeof responseError.json)responseError.json().then(err=>{const statusCode=(null==err?void 0:err.statusCode)||(null==err?void 0:err.code)||status+"";reject(new StorageVectorsApiError(fetch_getErrorMessage(err),status,statusCode))}).catch(()=>{const statusCode=status+"",message=responseError.statusText||`HTTP ${status} error`;reject(new StorageVectorsApiError(message,status,statusCode))});else{const statusCode=status+"",message=responseError.statusText||`HTTP ${status} error`;reject(new StorageVectorsApiError(message,status,statusCode))}}else reject(new StorageVectorsUnknownError(fetch_getErrorMessage(error),error))}))(error,reject,options))})})}function fetch_post(fetcher,url,body,options,parameters){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return fetch_handleRequest(fetcher,"POST",url,options,parameters,body)})}class VectorIndexApi{constructor(url,headers={},fetch){this.shouldThrowOnError=!1,this.url=url.replace(/\/$/,""),this.headers=Object.assign(Object.assign({},constants_DEFAULT_HEADERS),headers),this.fetch=vectors_helpers_resolveFetch(fetch)}throwOnError(){return this.shouldThrowOnError=!0,this}createIndex(options){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:(yield fetch_post(this.fetch,`${this.url}/CreateIndex`,options,{headers:this.headers}))||{},error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageVectorsError(error))return{data:null,error};throw error}})}getIndex(vectorBucketName,indexName){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:yield fetch_post(this.fetch,`${this.url}/GetIndex`,{vectorBucketName,indexName},{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageVectorsError(error))return{data:null,error};throw error}})}listIndexes(options){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:yield fetch_post(this.fetch,`${this.url}/ListIndexes`,options,{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageVectorsError(error))return{data:null,error};throw error}})}deleteIndex(vectorBucketName,indexName){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:(yield fetch_post(this.fetch,`${this.url}/DeleteIndex`,{vectorBucketName,indexName},{headers:this.headers}))||{},error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageVectorsError(error))return{data:null,error};throw error}})}}class VectorDataApi{constructor(url,headers={},fetch){this.shouldThrowOnError=!1,this.url=url.replace(/\/$/,""),this.headers=Object.assign(Object.assign({},constants_DEFAULT_HEADERS),headers),this.fetch=vectors_helpers_resolveFetch(fetch)}throwOnError(){return this.shouldThrowOnError=!0,this}putVectors(options){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{if(options.vectors.length<1||options.vectors.length>500)throw new Error("Vector batch size must be between 1 and 500 items");return{data:(yield fetch_post(this.fetch,`${this.url}/PutVectors`,options,{headers:this.headers}))||{},error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageVectorsError(error))return{data:null,error};throw error}})}getVectors(options){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:yield fetch_post(this.fetch,`${this.url}/GetVectors`,options,{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageVectorsError(error))return{data:null,error};throw error}})}listVectors(options){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{if(void 0!==options.segmentCount){if(options.segmentCount<1||options.segmentCount>16)throw new Error("segmentCount must be between 1 and 16");if(void 0!==options.segmentIndex&&(options.segmentIndex<0||options.segmentIndex>=options.segmentCount))throw new Error("segmentIndex must be between 0 and "+(options.segmentCount-1))}return{data:yield fetch_post(this.fetch,`${this.url}/ListVectors`,options,{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageVectorsError(error))return{data:null,error};throw error}})}queryVectors(options){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:yield fetch_post(this.fetch,`${this.url}/QueryVectors`,options,{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageVectorsError(error))return{data:null,error};throw error}})}deleteVectors(options){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{if(options.keys.length<1||options.keys.length>500)throw new Error("Keys batch size must be between 1 and 500 items");return{data:(yield fetch_post(this.fetch,`${this.url}/DeleteVectors`,options,{headers:this.headers}))||{},error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageVectorsError(error))return{data:null,error};throw error}})}}class VectorBucketApi{constructor(url,headers={},fetch){this.shouldThrowOnError=!1,this.url=url.replace(/\/$/,""),this.headers=Object.assign(Object.assign({},constants_DEFAULT_HEADERS),headers),this.fetch=vectors_helpers_resolveFetch(fetch)}throwOnError(){return this.shouldThrowOnError=!0,this}createBucket(vectorBucketName){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:(yield fetch_post(this.fetch,`${this.url}/CreateVectorBucket`,{vectorBucketName},{headers:this.headers}))||{},error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageVectorsError(error))return{data:null,error};throw error}})}getBucket(vectorBucketName){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:yield fetch_post(this.fetch,`${this.url}/GetVectorBucket`,{vectorBucketName},{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageVectorsError(error))return{data:null,error};throw error}})}listBuckets(){return(0,tslib_es6.__awaiter)(this,arguments,void 0,function*(options={}){try{return{data:yield fetch_post(this.fetch,`${this.url}/ListVectorBuckets`,options,{headers:this.headers}),error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageVectorsError(error))return{data:null,error};throw error}})}deleteBucket(vectorBucketName){return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){try{return{data:(yield fetch_post(this.fetch,`${this.url}/DeleteVectorBucket`,{vectorBucketName},{headers:this.headers}))||{},error:null}}catch(error){if(this.shouldThrowOnError)throw error;if(isStorageVectorsError(error))return{data:null,error};throw error}})}}class StorageVectorsClient extends VectorBucketApi{constructor(url,options={}){super(url,options.headers||{},options.fetch)}from(vectorBucketName){return new VectorBucketScope(this.url,this.headers,vectorBucketName,this.fetch)}}class VectorBucketScope extends VectorIndexApi{constructor(url,headers,vectorBucketName,fetch){super(url,headers,fetch),this.vectorBucketName=vectorBucketName}createIndex(options){const _super=Object.create(null,{createIndex:{get:()=>super.createIndex}});return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return _super.createIndex.call(this,Object.assign(Object.assign({},options),{vectorBucketName:this.vectorBucketName}))})}listIndexes(){const _super=Object.create(null,{listIndexes:{get:()=>super.listIndexes}});return(0,tslib_es6.__awaiter)(this,arguments,void 0,function*(options={}){return _super.listIndexes.call(this,Object.assign(Object.assign({},options),{vectorBucketName:this.vectorBucketName}))})}getIndex(indexName){const _super=Object.create(null,{getIndex:{get:()=>super.getIndex}});return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return _super.getIndex.call(this,this.vectorBucketName,indexName)})}deleteIndex(indexName){const _super=Object.create(null,{deleteIndex:{get:()=>super.deleteIndex}});return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return _super.deleteIndex.call(this,this.vectorBucketName,indexName)})}index(indexName){return new VectorIndexScope(this.url,this.headers,this.vectorBucketName,indexName,this.fetch)}}class VectorIndexScope extends VectorDataApi{constructor(url,headers,vectorBucketName,indexName,fetch){super(url,headers,fetch),this.vectorBucketName=vectorBucketName,this.indexName=indexName}putVectors(options){const _super=Object.create(null,{putVectors:{get:()=>super.putVectors}});return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return _super.putVectors.call(this,Object.assign(Object.assign({},options),{vectorBucketName:this.vectorBucketName,indexName:this.indexName}))})}getVectors(options){const _super=Object.create(null,{getVectors:{get:()=>super.getVectors}});return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return _super.getVectors.call(this,Object.assign(Object.assign({},options),{vectorBucketName:this.vectorBucketName,indexName:this.indexName}))})}listVectors(){const _super=Object.create(null,{listVectors:{get:()=>super.listVectors}});return(0,tslib_es6.__awaiter)(this,arguments,void 0,function*(options={}){return _super.listVectors.call(this,Object.assign(Object.assign({},options),{vectorBucketName:this.vectorBucketName,indexName:this.indexName}))})}queryVectors(options){const _super=Object.create(null,{queryVectors:{get:()=>super.queryVectors}});return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return _super.queryVectors.call(this,Object.assign(Object.assign({},options),{vectorBucketName:this.vectorBucketName,indexName:this.indexName}))})}deleteVectors(options){const _super=Object.create(null,{deleteVectors:{get:()=>super.deleteVectors}});return(0,tslib_es6.__awaiter)(this,void 0,void 0,function*(){return _super.deleteVectors.call(this,Object.assign(Object.assign({},options),{vectorBucketName:this.vectorBucketName,indexName:this.indexName}))})}}class StorageClient extends StorageBucketApi{constructor(url,headers={},fetch,opts){super(url,headers,fetch,opts)}from(id){return new StorageFileApi(this.url,this.headers,id,this.fetch)}get vectors(){return new StorageVectorsClient(this.url+"/vector",{headers:this.headers,fetch:this.fetch})}get analytics(){return new StorageAnalyticsApi(this.url+"/iceberg",this.headers,this.fetch)}}let JS_ENV="";JS_ENV="undefined"!=typeof Deno?"deno":"undefined"!=typeof document?"web":"undefined"!=typeof navigator&&"ReactNative"===navigator.product?"react-native":"node";const DEFAULT_GLOBAL_OPTIONS={headers:{"X-Client-Info":`supabase-js-${JS_ENV}/2.79.0`}},DEFAULT_DB_OPTIONS={schema:"public"},DEFAULT_AUTH_OPTIONS={autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,flowType:"implicit"},DEFAULT_REALTIME_OPTIONS={},fetch_resolveFetch=customFetch=>customFetch?(...args)=>customFetch(...args):(...args)=>fetch(...args),fetchWithAuth=(supabaseKey,getAccessToken,customFetch)=>{const fetch=fetch_resolveFetch(customFetch),HeadersConstructor=Headers;return async(input,init)=>{var _a;const accessToken=null!==(_a=await getAccessToken())&&void 0!==_a?_a:supabaseKey;let headers=new HeadersConstructor(null==init?void 0:init.headers);return headers.has("apikey")||headers.set("apikey",supabaseKey),headers.has("Authorization")||headers.set("Authorization",`Bearer ${accessToken}`),fetch(input,Object.assign(Object.assign({},init),{headers}))}};const module_lib_constants_DEFAULT_HEADERS={"X-Client-Info":"gotrue-js/2.79.0"},API_VERSIONS_2024_01_01={timestamp:Date.parse("2024-01-01T00:00:00.0Z"),name:"2024-01-01"},BASE64URL_REGEX=/^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;class AuthError extends Error{constructor(message,status,code){super(message),this.__isAuthError=!0,this.name="AuthError",this.status=status,this.code=code}}function isAuthError(error){return"object"==typeof error&&null!==error&&"__isAuthError"in error}class AuthApiError extends AuthError{constructor(message,status,code){super(message,status,code),this.name="AuthApiError",this.status=status,this.code=code}}class AuthUnknownError extends AuthError{constructor(message,originalError){super(message),this.name="AuthUnknownError",this.originalError=originalError}}class CustomAuthError extends AuthError{constructor(message,name,status,code){super(message,status,code),this.name=name,this.status=status}}class AuthSessionMissingError extends CustomAuthError{constructor(){super("Auth session missing!","AuthSessionMissingError",400,void 0)}}class AuthInvalidTokenResponseError extends CustomAuthError{constructor(){super("Auth session or user missing","AuthInvalidTokenResponseError",500,void 0)}}class AuthInvalidCredentialsError extends CustomAuthError{constructor(message){super(message,"AuthInvalidCredentialsError",400,void 0)}}class AuthImplicitGrantRedirectError extends CustomAuthError{constructor(message,details=null){super(message,"AuthImplicitGrantRedirectError",500,void 0),this.details=null,this.details=details}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}class AuthPKCEGrantCodeExchangeError extends CustomAuthError{constructor(message,details=null){super(message,"AuthPKCEGrantCodeExchangeError",500,void 0),this.details=null,this.details=details}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}class AuthRetryableFetchError extends CustomAuthError{constructor(message,status){super(message,"AuthRetryableFetchError",status,void 0)}}function isAuthRetryableFetchError(error){return isAuthError(error)&&"AuthRetryableFetchError"===error.name}class AuthWeakPasswordError extends CustomAuthError{constructor(message,status,reasons){super(message,"AuthWeakPasswordError",status,"weak_password"),this.reasons=reasons}}class AuthInvalidJwtError extends CustomAuthError{constructor(message){super(message,"AuthInvalidJwtError",400,"invalid_jwt")}}const TO_BASE64URL="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""),IGNORE_BASE64URL=" \t\n\r=".split(""),FROM_BASE64URL=(()=>{const charMap=new Array(128);for(let i=0;i<charMap.length;i+=1)charMap[i]=-1;for(let i=0;i<IGNORE_BASE64URL.length;i+=1)charMap[IGNORE_BASE64URL[i].charCodeAt(0)]=-2;for(let i=0;i<TO_BASE64URL.length;i+=1)charMap[TO_BASE64URL[i].charCodeAt(0)]=i;return charMap})();function byteToBase64URL(byte,state,emit){if(null!==byte)for(state.queue=state.queue<<8|byte,state.queuedBits+=8;state.queuedBits>=6;){const pos=state.queue>>state.queuedBits-6&63;emit(TO_BASE64URL[pos]),state.queuedBits-=6}else if(state.queuedBits>0)for(state.queue=state.queue<<6-state.queuedBits,state.queuedBits=6;state.queuedBits>=6;){const pos=state.queue>>state.queuedBits-6&63;emit(TO_BASE64URL[pos]),state.queuedBits-=6}}function byteFromBase64URL(charCode,state,emit){const bits=FROM_BASE64URL[charCode];if(!(bits>-1)){if(-2===bits)return;throw new Error(`Invalid Base64-URL character "${String.fromCharCode(charCode)}"`)}for(state.queue=state.queue<<6|bits,state.queuedBits+=6;state.queuedBits>=8;)emit(state.queue>>state.queuedBits-8&255),state.queuedBits-=8}function stringFromBase64URL(str){const conv=[],utf8Emit=codepoint=>{conv.push(String.fromCodePoint(codepoint))},utf8State={utf8seq:0,codepoint:0},b64State={queue:0,queuedBits:0},byteEmit=byte=>{!function stringFromUTF8(byte,state,emit){if(0===state.utf8seq){if(byte<=127)return void emit(byte);for(let leadingBit=1;leadingBit<6;leadingBit+=1)if(!(byte>>7-leadingBit&1)){state.utf8seq=leadingBit;break}if(2===state.utf8seq)state.codepoint=31&byte;else if(3===state.utf8seq)state.codepoint=15&byte;else{if(4!==state.utf8seq)throw new Error("Invalid UTF-8 sequence");state.codepoint=7&byte}state.utf8seq-=1}else if(state.utf8seq>0){if(byte<=127)throw new Error("Invalid UTF-8 sequence");state.codepoint=state.codepoint<<6|63&byte,state.utf8seq-=1,0===state.utf8seq&&emit(state.codepoint)}}(byte,utf8State,utf8Emit)};for(let i=0;i<str.length;i+=1)byteFromBase64URL(str.charCodeAt(i),b64State,byteEmit);return conv.join("")}function codepointToUTF8(codepoint,emit){if(!(codepoint<=127)){if(codepoint<=2047)return emit(192|codepoint>>6),void emit(128|63&codepoint);if(codepoint<=65535)return emit(224|codepoint>>12),emit(128|codepoint>>6&63),void emit(128|63&codepoint);if(codepoint<=1114111)return emit(240|codepoint>>18),emit(128|codepoint>>12&63),emit(128|codepoint>>6&63),void emit(128|63&codepoint);throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`)}emit(codepoint)}function stringToUTF8(str,emit){for(let i=0;i<str.length;i+=1){let codepoint=str.charCodeAt(i);if(codepoint>55295&&codepoint<=56319){const highSurrogate=1024*(codepoint-55296)&65535;codepoint=65536+(str.charCodeAt(i+1)-56320&65535|highSurrogate),i+=1}codepointToUTF8(codepoint,emit)}}function base64UrlToUint8Array(str){const result=[],state={queue:0,queuedBits:0},onByte=byte=>{result.push(byte)};for(let i=0;i<str.length;i+=1)byteFromBase64URL(str.charCodeAt(i),state,onByte);return new Uint8Array(result)}function bytesToBase64URL(bytes){const result=[],state={queue:0,queuedBits:0},onChar=char=>{result.push(char)};return bytes.forEach(byte=>byteToBase64URL(byte,state,onChar)),byteToBase64URL(null,state,onChar),result.join("")}var helpers_console=__webpack_require__("./node_modules/console-browserify/index.js");const helpers_isBrowser=()=>"undefined"!=typeof window&&"undefined"!=typeof document,localStorageWriteTests={tested:!1,writable:!1},supportsLocalStorage=()=>{if(!helpers_isBrowser())return!1;try{if("object"!=typeof globalThis.localStorage)return!1}catch(e){return!1}if(localStorageWriteTests.tested)return localStorageWriteTests.writable;const randomKey=`lswt-${Math.random()}${Math.random()}`;try{globalThis.localStorage.setItem(randomKey,randomKey),globalThis.localStorage.removeItem(randomKey),localStorageWriteTests.tested=!0,localStorageWriteTests.writable=!0}catch(e){localStorageWriteTests.tested=!0,localStorageWriteTests.writable=!1}return localStorageWriteTests.writable};const lib_helpers_resolveFetch=customFetch=>customFetch?(...args)=>customFetch(...args):(...args)=>fetch(...args),setItemAsync=async(storage,key,data)=>{await storage.setItem(key,JSON.stringify(data))},getItemAsync=async(storage,key)=>{const value=await storage.getItem(key);if(!value)return null;try{return JSON.parse(value)}catch(_a){return value}},removeItemAsync=async(storage,key)=>{await storage.removeItem(key)};class Deferred{constructor(){this.promise=new Deferred.promiseConstructor((res,rej)=>{this.resolve=res,this.reject=rej})}}function decodeJWT(token){const parts=token.split(".");if(3!==parts.length)throw new AuthInvalidJwtError("Invalid JWT structure");for(let i=0;i<parts.length;i++)if(!BASE64URL_REGEX.test(parts[i]))throw new AuthInvalidJwtError("JWT not in base64url format");return{header:JSON.parse(stringFromBase64URL(parts[0])),payload:JSON.parse(stringFromBase64URL(parts[1])),signature:base64UrlToUint8Array(parts[2]),raw:{header:parts[0],payload:parts[1]}}}function dec2hex(dec){return("0"+dec.toString(16)).substr(-2)}async function generatePKCEChallenge(verifier){if(!("undefined"!=typeof crypto&&void 0!==crypto.subtle&&"undefined"!=typeof TextEncoder))return helpers_console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),verifier;const hashed=await async function sha256(randomString){const encodedData=(new TextEncoder).encode(randomString),hash=await crypto.subtle.digest("SHA-256",encodedData),bytes=new Uint8Array(hash);return Array.from(bytes).map(c=>String.fromCharCode(c)).join("")}(verifier);return btoa(hashed).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}async function getCodeChallengeAndMethod(storage,storageKey,isPasswordRecovery=!1){const codeVerifier=function generatePKCEVerifier(){const array=new Uint32Array(56);if("undefined"==typeof crypto){const charSet="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",charSetLen=charSet.length;let verifier="";for(let i=0;i<56;i++)verifier+=charSet.charAt(Math.floor(Math.random()*charSetLen));return verifier}return crypto.getRandomValues(array),Array.from(array,dec2hex).join("")}();let storedCodeVerifier=codeVerifier;isPasswordRecovery&&(storedCodeVerifier+="/PASSWORD_RECOVERY"),await setItemAsync(storage,`${storageKey}-code-verifier`,storedCodeVerifier);const codeChallenge=await generatePKCEChallenge(codeVerifier);return[codeChallenge,codeVerifier===codeChallenge?"plain":"s256"]}Deferred.promiseConstructor=Promise;const API_VERSION_REGEX=/^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;const UUID_REGEX=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;function validateUUID(str){if(!UUID_REGEX.test(str))throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")}function userNotAvailableProxy(){return new Proxy({},{get:(target,prop)=>{if("__isUserNotAvailableProxy"===prop)return!0;if("symbol"==typeof prop){const sProp=prop.toString();if("Symbol(Symbol.toPrimitive)"===sProp||"Symbol(Symbol.toStringTag)"===sProp||"Symbol(util.inspect.custom)"===sProp)return}throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${prop}" property of the session object is not supported. Please use getUser() instead.`)},set:(_target,prop)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)},deleteProperty:(_target,prop)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)}})}function deepClone(obj){return JSON.parse(JSON.stringify(obj))}var fetch_console=__webpack_require__("./node_modules/console-browserify/index.js");const lib_fetch_getErrorMessage=err=>err.msg||err.message||err.error_description||err.error||JSON.stringify(err),NETWORK_ERROR_CODES=[502,503,504];async function lib_fetch_handleError(error){var _a,maybeResponse;if(!("object"==typeof(maybeResponse=error)&&null!==maybeResponse&&"status"in maybeResponse&&"ok"in maybeResponse&&"json"in maybeResponse&&"function"==typeof maybeResponse.json))throw new AuthRetryableFetchError(lib_fetch_getErrorMessage(error),0);if(NETWORK_ERROR_CODES.includes(error.status))throw new AuthRetryableFetchError(lib_fetch_getErrorMessage(error),error.status);let data,errorCode;try{data=await error.json()}catch(e){throw new AuthUnknownError(lib_fetch_getErrorMessage(e),e)}const responseAPIVersion=function parseResponseAPIVersion(response){const apiVersion=response.headers.get("X-Supabase-Api-Version");if(!apiVersion)return null;if(!apiVersion.match(API_VERSION_REGEX))return null;try{return new Date(`${apiVersion}T00:00:00.0Z`)}catch(e){return null}}(error);if(responseAPIVersion&&responseAPIVersion.getTime()>=API_VERSIONS_2024_01_01.timestamp&&"object"==typeof data&&data&&"string"==typeof data.code?errorCode=data.code:"object"==typeof data&&data&&"string"==typeof data.error_code&&(errorCode=data.error_code),errorCode){if("weak_password"===errorCode)throw new AuthWeakPasswordError(lib_fetch_getErrorMessage(data),error.status,(null===(_a=data.weak_password)||void 0===_a?void 0:_a.reasons)||[]);if("session_not_found"===errorCode)throw new AuthSessionMissingError}else if("object"==typeof data&&data&&"object"==typeof data.weak_password&&data.weak_password&&Array.isArray(data.weak_password.reasons)&&data.weak_password.reasons.length&&data.weak_password.reasons.reduce((a,i)=>a&&"string"==typeof i,!0))throw new AuthWeakPasswordError(lib_fetch_getErrorMessage(data),error.status,data.weak_password.reasons);throw new AuthApiError(lib_fetch_getErrorMessage(data),error.status||500,errorCode)}async function _request(fetcher,method,url,options){var _a;const headers=Object.assign({},null==options?void 0:options.headers);headers["X-Supabase-Api-Version"]||(headers["X-Supabase-Api-Version"]=API_VERSIONS_2024_01_01.name),(null==options?void 0:options.jwt)&&(headers.Authorization=`Bearer ${options.jwt}`);const qs=null!==(_a=null==options?void 0:options.query)&&void 0!==_a?_a:{};(null==options?void 0:options.redirectTo)&&(qs.redirect_to=options.redirectTo);const queryString=Object.keys(qs).length?"?"+new URLSearchParams(qs).toString():"",data=await async function lib_fetch_handleRequest(fetcher,method,url,options,parameters,body){const requestParams=((method,options,parameters,body)=>{const params={method,headers:(null==options?void 0:options.headers)||{}};return"GET"===method?params:(params.headers=Object.assign({"Content-Type":"application/json;charset=UTF-8"},null==options?void 0:options.headers),params.body=JSON.stringify(body),Object.assign(Object.assign({},params),parameters))})(method,options,parameters,body);let result;try{result=await fetcher(url,Object.assign({},requestParams))}catch(e){throw fetch_console.error(e),new AuthRetryableFetchError(lib_fetch_getErrorMessage(e),0)}result.ok||await lib_fetch_handleError(result);if(null==options?void 0:options.noResolveJson)return result;try{return await result.json()}catch(e){await lib_fetch_handleError(e)}}(fetcher,method,url+queryString,{headers,noResolveJson:null==options?void 0:options.noResolveJson},{},null==options?void 0:options.body);return(null==options?void 0:options.xform)?null==options?void 0:options.xform(data):{data:Object.assign({},data),error:null}}function _sessionResponse(data){var _a;let session=null;(function hasSession(data){return data.access_token&&data.refresh_token&&data.expires_in})(data)&&(session=Object.assign({},data),data.expires_at||(session.expires_at=function expiresAt(expiresIn){return Math.round(Date.now()/1e3)+expiresIn}(data.expires_in)));return{data:{session,user:null!==(_a=data.user)&&void 0!==_a?_a:data},error:null}}function _sessionResponsePassword(data){const response=_sessionResponse(data);return!response.error&&data.weak_password&&"object"==typeof data.weak_password&&Array.isArray(data.weak_password.reasons)&&data.weak_password.reasons.length&&data.weak_password.message&&"string"==typeof data.weak_password.message&&data.weak_password.reasons.reduce((a,i)=>a&&"string"==typeof i,!0)&&(response.data.weak_password=data.weak_password),response}function _userResponse(data){var _a;return{data:{user:null!==(_a=data.user)&&void 0!==_a?_a:data},error:null}}function _ssoResponse(data){return{data,error:null}}function _generateLinkResponse(data){const{action_link,email_otp,hashed_token,redirect_to,verification_type}=data,rest=(0,tslib_es6.__rest)(data,["action_link","email_otp","hashed_token","redirect_to","verification_type"]);return{data:{properties:{action_link,email_otp,hashed_token,redirect_to,verification_type},user:Object.assign({},rest)},error:null}}function _noResolveJsonResponse(data){return data}const SIGN_OUT_SCOPES=["global","local","others"];class GoTrueAdminApi_GoTrueAdminApi{constructor({url="",headers={},fetch}){this.url=url,this.headers=headers,this.fetch=lib_helpers_resolveFetch(fetch),this.mfa={listFactors:this._listFactors.bind(this),deleteFactor:this._deleteFactor.bind(this)},this.oauth={listClients:this._listOAuthClients.bind(this),createClient:this._createOAuthClient.bind(this),getClient:this._getOAuthClient.bind(this),updateClient:this._updateOAuthClient.bind(this),deleteClient:this._deleteOAuthClient.bind(this),regenerateClientSecret:this._regenerateOAuthClientSecret.bind(this)}}async signOut(jwt,scope=SIGN_OUT_SCOPES[0]){if(SIGN_OUT_SCOPES.indexOf(scope)<0)throw new Error(`@supabase/auth-js: Parameter scope must be one of ${SIGN_OUT_SCOPES.join(", ")}`);try{return await _request(this.fetch,"POST",`${this.url}/logout?scope=${scope}`,{headers:this.headers,jwt,noResolveJson:!0}),{data:null,error:null}}catch(error){if(isAuthError(error))return{data:null,error};throw error}}async inviteUserByEmail(email,options={}){try{return await _request(this.fetch,"POST",`${this.url}/invite`,{body:{email,data:options.data},headers:this.headers,redirectTo:options.redirectTo,xform:_userResponse})}catch(error){if(isAuthError(error))return{data:{user:null},error};throw error}}async generateLink(params){try{const{options}=params,rest=(0,tslib_es6.__rest)(params,["options"]),body=Object.assign(Object.assign({},rest),options);return"newEmail"in rest&&(body.new_email=null==rest?void 0:rest.newEmail,delete body.newEmail),await _request(this.fetch,"POST",`${this.url}/admin/generate_link`,{body,headers:this.headers,xform:_generateLinkResponse,redirectTo:null==options?void 0:options.redirectTo})}catch(error){if(isAuthError(error))return{data:{properties:null,user:null},error};throw error}}async createUser(attributes){try{return await _request(this.fetch,"POST",`${this.url}/admin/users`,{body:attributes,headers:this.headers,xform:_userResponse})}catch(error){if(isAuthError(error))return{data:{user:null},error};throw error}}async listUsers(params){var _a,_b,_c,_d,_e,_f,_g;try{const pagination={nextPage:null,lastPage:0,total:0},response=await _request(this.fetch,"GET",`${this.url}/admin/users`,{headers:this.headers,noResolveJson:!0,query:{page:null!==(_b=null===(_a=null==params?void 0:params.page)||void 0===_a?void 0:_a.toString())&&void 0!==_b?_b:"",per_page:null!==(_d=null===(_c=null==params?void 0:params.perPage)||void 0===_c?void 0:_c.toString())&&void 0!==_d?_d:""},xform:_noResolveJsonResponse});if(response.error)throw response.error;const users=await response.json(),total=null!==(_e=response.headers.get("x-total-count"))&&void 0!==_e?_e:0,links=null!==(_g=null===(_f=response.headers.get("link"))||void 0===_f?void 0:_f.split(","))&&void 0!==_g?_g:[];return links.length>0&&(links.forEach(link=>{const page=parseInt(link.split(";")[0].split("=")[1].substring(0,1)),rel=JSON.parse(link.split(";")[1].split("=")[1]);pagination[`${rel}Page`]=page}),pagination.total=parseInt(total)),{data:Object.assign(Object.assign({},users),pagination),error:null}}catch(error){if(isAuthError(error))return{data:{users:[]},error};throw error}}async getUserById(uid){validateUUID(uid);try{return await _request(this.fetch,"GET",`${this.url}/admin/users/${uid}`,{headers:this.headers,xform:_userResponse})}catch(error){if(isAuthError(error))return{data:{user:null},error};throw error}}async updateUserById(uid,attributes){validateUUID(uid);try{return await _request(this.fetch,"PUT",`${this.url}/admin/users/${uid}`,{body:attributes,headers:this.headers,xform:_userResponse})}catch(error){if(isAuthError(error))return{data:{user:null},error};throw error}}async deleteUser(id,shouldSoftDelete=!1){validateUUID(id);try{return await _request(this.fetch,"DELETE",`${this.url}/admin/users/${id}`,{headers:this.headers,body:{should_soft_delete:shouldSoftDelete},xform:_userResponse})}catch(error){if(isAuthError(error))return{data:{user:null},error};throw error}}async _listFactors(params){validateUUID(params.userId);try{const{data,error}=await _request(this.fetch,"GET",`${this.url}/admin/users/${params.userId}/factors`,{headers:this.headers,xform:factors=>({data:{factors},error:null})});return{data,error}}catch(error){if(isAuthError(error))return{data:null,error};throw error}}async _deleteFactor(params){validateUUID(params.userId),validateUUID(params.id);try{return{data:await _request(this.fetch,"DELETE",`${this.url}/admin/users/${params.userId}/factors/${params.id}`,{headers:this.headers}),error:null}}catch(error){if(isAuthError(error))return{data:null,error};throw error}}async _listOAuthClients(params){var _a,_b,_c,_d,_e,_f,_g;try{const pagination={nextPage:null,lastPage:0,total:0},response=await _request(this.fetch,"GET",`${this.url}/admin/oauth/clients`,{headers:this.headers,noResolveJson:!0,query:{page:null!==(_b=null===(_a=null==params?void 0:params.page)||void 0===_a?void 0:_a.toString())&&void 0!==_b?_b:"",per_page:null!==(_d=null===(_c=null==params?void 0:params.perPage)||void 0===_c?void 0:_c.toString())&&void 0!==_d?_d:""},xform:_noResolveJsonResponse});if(response.error)throw response.error;const clients=await response.json(),total=null!==(_e=response.headers.get("x-total-count"))&&void 0!==_e?_e:0,links=null!==(_g=null===(_f=response.headers.get("link"))||void 0===_f?void 0:_f.split(","))&&void 0!==_g?_g:[];return links.length>0&&(links.forEach(link=>{const page=parseInt(link.split(";")[0].split("=")[1].substring(0,1)),rel=JSON.parse(link.split(";")[1].split("=")[1]);pagination[`${rel}Page`]=page}),pagination.total=parseInt(total)),{data:Object.assign(Object.assign({},clients),pagination),error:null}}catch(error){if(isAuthError(error))return{data:{clients:[]},error};throw error}}async _createOAuthClient(params){try{return await _request(this.fetch,"POST",`${this.url}/admin/oauth/clients`,{body:params,headers:this.headers,xform:client=>({data:client,error:null})})}catch(error){if(isAuthError(error))return{data:null,error};throw error}}async _getOAuthClient(clientId){try{return await _request(this.fetch,"GET",`${this.url}/admin/oauth/clients/${clientId}`,{headers:this.headers,xform:client=>({data:client,error:null})})}catch(error){if(isAuthError(error))return{data:null,error};throw error}}async _updateOAuthClient(clientId,params){try{return await _request(this.fetch,"PUT",`${this.url}/admin/oauth/clients/${clientId}`,{body:params,headers:this.headers,xform:client=>({data:client,error:null})})}catch(error){if(isAuthError(error))return{data:null,error};throw error}}async _deleteOAuthClient(clientId){try{return await _request(this.fetch,"DELETE",`${this.url}/admin/oauth/clients/${clientId}`,{headers:this.headers,noResolveJson:!0}),{data:null,error:null}}catch(error){if(isAuthError(error))return{data:null,error};throw error}}async _regenerateOAuthClientSecret(clientId){try{return await _request(this.fetch,"POST",`${this.url}/admin/oauth/clients/${clientId}/regenerate_secret`,{headers:this.headers,xform:client=>({data:client,error:null})})}catch(error){if(isAuthError(error))return{data:null,error};throw error}}}function memoryLocalStorageAdapter(store={}){return{getItem:key=>store[key]||null,setItem:(key,value)=>{store[key]=value},removeItem:key=>{delete store[key]}}}var locks_console=__webpack_require__("./node_modules/console-browserify/index.js");const internals_debug=!!(globalThis&&supportsLocalStorage()&&globalThis.localStorage&&"true"===globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug"));class LockAcquireTimeoutError extends Error{constructor(message){super(message),this.isAcquireTimeout=!0}}class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError{}async function navigatorLock(name,acquireTimeout,fn){internals_debug&&locks_console.log("@supabase/gotrue-js: navigatorLock: acquire lock",name,acquireTimeout);const abortController=new globalThis.AbortController;return acquireTimeout>0&&setTimeout(()=>{abortController.abort(),internals_debug&&locks_console.log("@supabase/gotrue-js: navigatorLock acquire timed out",name)},acquireTimeout),await Promise.resolve().then(()=>globalThis.navigator.locks.request(name,0===acquireTimeout?{mode:"exclusive",ifAvailable:!0}:{mode:"exclusive",signal:abortController.signal},async lock=>{if(!lock){if(0===acquireTimeout)throw internals_debug&&locks_console.log("@supabase/gotrue-js: navigatorLock: not immediately available",name),new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name}" immediately failed`);if(internals_debug)try{const result=await globalThis.navigator.locks.query();locks_console.log("@supabase/gotrue-js: Navigator LockManager state",JSON.stringify(result,null,"  "))}catch(e){locks_console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state",e)}return locks_console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),await fn()}internals_debug&&locks_console.log("@supabase/gotrue-js: navigatorLock: acquired",name,lock.name);try{return await fn()}finally{internals_debug&&locks_console.log("@supabase/gotrue-js: navigatorLock: released",name,lock.name)}}))}function getAddress(address){if(!/^0x[a-fA-F0-9]{40}$/.test(address))throw new Error(`@supabase/auth-js: Address "${address}" is invalid.`);return address.toLowerCase()}function toHex(value){const bytes=(new TextEncoder).encode(value);return"0x"+Array.from(bytes,byte=>byte.toString(16).padStart(2,"0")).join("")}class WebAuthnError extends Error{constructor({message,code,cause,name}){var _a;super(message,{cause}),this.__isWebAuthnError=!0,this.name=null!==(_a=null!=name?name:cause instanceof Error?cause.name:void 0)&&void 0!==_a?_a:"Unknown Error",this.code=code}}class WebAuthnUnknownError extends WebAuthnError{constructor(message,originalError){super({code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:originalError,message}),this.name="WebAuthnUnknownError",this.originalError=originalError}}function identifyRegistrationError({error,options}){var _a,_b,_c;const{publicKey}=options;if(!publicKey)throw Error("options was missing required publicKey property");if("AbortError"===error.name){if(options.signal instanceof AbortSignal)return new WebAuthnError({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:error})}else if("ConstraintError"===error.name){if(!0===(null===(_a=publicKey.authenticatorSelection)||void 0===_a?void 0:_a.requireResidentKey))return new WebAuthnError({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:error});if("conditional"===options.mediation&&"required"===(null===(_b=publicKey.authenticatorSelection)||void 0===_b?void 0:_b.userVerification))return new WebAuthnError({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:error});if("required"===(null===(_c=publicKey.authenticatorSelection)||void 0===_c?void 0:_c.userVerification))return new WebAuthnError({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:error})}else{if("InvalidStateError"===error.name)return new WebAuthnError({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:error});if("NotAllowedError"===error.name)return new WebAuthnError({message:error.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:error});if("NotSupportedError"===error.name){return 0===publicKey.pubKeyCredParams.filter(param=>"public-key"===param.type).length?new WebAuthnError({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:error}):new WebAuthnError({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:error})}if("SecurityError"===error.name){const effectiveDomain=window.location.hostname;if(!isValidDomain(effectiveDomain))return new WebAuthnError({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:error});if(publicKey.rp.id!==effectiveDomain)return new WebAuthnError({message:`The RP ID "${publicKey.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:error})}else if("TypeError"===error.name){if(publicKey.user.id.byteLength<1||publicKey.user.id.byteLength>64)return new WebAuthnError({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:error})}else if("UnknownError"===error.name)return new WebAuthnError({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:error})}return new WebAuthnError({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:error})}function identifyAuthenticationError({error,options}){const{publicKey}=options;if(!publicKey)throw Error("options was missing required publicKey property");if("AbortError"===error.name){if(options.signal instanceof AbortSignal)return new WebAuthnError({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:error})}else{if("NotAllowedError"===error.name)return new WebAuthnError({message:error.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:error});if("SecurityError"===error.name){const effectiveDomain=window.location.hostname;if(!isValidDomain(effectiveDomain))return new WebAuthnError({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:error});if(publicKey.rpId!==effectiveDomain)return new WebAuthnError({message:`The RP ID "${publicKey.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:error})}else if("UnknownError"===error.name)return new WebAuthnError({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:error})}return new WebAuthnError({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:error})}const webAuthnAbortService=new class WebAuthnAbortService{createNewAbortSignal(){if(this.controller){const abortError=new Error("Cancelling existing WebAuthn API call for new one");abortError.name="AbortError",this.controller.abort(abortError)}const newController=new AbortController;return this.controller=newController,newController.signal}cancelCeremony(){if(this.controller){const abortError=new Error("Manually cancelling existing WebAuthn API call");abortError.name="AbortError",this.controller.abort(abortError),this.controller=void 0}}};function deserializeCredentialCreationOptions(options){if(!options)throw new Error("Credential creation options are required");if("undefined"!=typeof PublicKeyCredential&&"parseCreationOptionsFromJSON"in PublicKeyCredential&&"function"==typeof PublicKeyCredential.parseCreationOptionsFromJSON)return PublicKeyCredential.parseCreationOptionsFromJSON(options);const{challenge:challengeStr,user:userOpts,excludeCredentials}=options,restOptions=(0,tslib_es6.__rest)(options,["challenge","user","excludeCredentials"]),challenge=base64UrlToUint8Array(challengeStr).buffer,user=Object.assign(Object.assign({},userOpts),{id:base64UrlToUint8Array(userOpts.id).buffer}),result=Object.assign(Object.assign({},restOptions),{challenge,user});if(excludeCredentials&&excludeCredentials.length>0){result.excludeCredentials=new Array(excludeCredentials.length);for(let i=0;i<excludeCredentials.length;i++){const cred=excludeCredentials[i];result.excludeCredentials[i]=Object.assign(Object.assign({},cred),{id:base64UrlToUint8Array(cred.id).buffer,type:cred.type||"public-key",transports:cred.transports})}}return result}function deserializeCredentialRequestOptions(options){if(!options)throw new Error("Credential request options are required");if("undefined"!=typeof PublicKeyCredential&&"parseRequestOptionsFromJSON"in PublicKeyCredential&&"function"==typeof PublicKeyCredential.parseRequestOptionsFromJSON)return PublicKeyCredential.parseRequestOptionsFromJSON(options);const{challenge:challengeStr,allowCredentials}=options,restOptions=(0,tslib_es6.__rest)(options,["challenge","allowCredentials"]),challenge=base64UrlToUint8Array(challengeStr).buffer,result=Object.assign(Object.assign({},restOptions),{challenge});if(allowCredentials&&allowCredentials.length>0){result.allowCredentials=new Array(allowCredentials.length);for(let i=0;i<allowCredentials.length;i++){const cred=allowCredentials[i];result.allowCredentials[i]=Object.assign(Object.assign({},cred),{id:base64UrlToUint8Array(cred.id).buffer,type:cred.type||"public-key",transports:cred.transports})}}return result}function serializeCredentialCreationResponse(credential){var _a;if("toJSON"in credential&&"function"==typeof credential.toJSON)return credential.toJSON();const credentialWithAttachment=credential;return{id:credential.id,rawId:credential.id,response:{attestationObject:bytesToBase64URL(new Uint8Array(credential.response.attestationObject)),clientDataJSON:bytesToBase64URL(new Uint8Array(credential.response.clientDataJSON))},type:"public-key",clientExtensionResults:credential.getClientExtensionResults(),authenticatorAttachment:null!==(_a=credentialWithAttachment.authenticatorAttachment)&&void 0!==_a?_a:void 0}}function serializeCredentialRequestResponse(credential){var _a;if("toJSON"in credential&&"function"==typeof credential.toJSON)return credential.toJSON();const credentialWithAttachment=credential,clientExtensionResults=credential.getClientExtensionResults(),assertionResponse=credential.response;return{id:credential.id,rawId:credential.id,response:{authenticatorData:bytesToBase64URL(new Uint8Array(assertionResponse.authenticatorData)),clientDataJSON:bytesToBase64URL(new Uint8Array(assertionResponse.clientDataJSON)),signature:bytesToBase64URL(new Uint8Array(assertionResponse.signature)),userHandle:assertionResponse.userHandle?bytesToBase64URL(new Uint8Array(assertionResponse.userHandle)):void 0},type:"public-key",clientExtensionResults,authenticatorAttachment:null!==(_a=credentialWithAttachment.authenticatorAttachment)&&void 0!==_a?_a:void 0}}function isValidDomain(hostname){return"localhost"===hostname||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname)}function browserSupportsWebAuthn(){var _a,_b;return!!(helpers_isBrowser()&&"PublicKeyCredential"in window&&window.PublicKeyCredential&&"credentials"in navigator&&"function"==typeof(null===(_a=null===navigator||void 0===navigator?void 0:navigator.credentials)||void 0===_a?void 0:_a.create)&&"function"==typeof(null===(_b=null===navigator||void 0===navigator?void 0:navigator.credentials)||void 0===_b?void 0:_b.get))}const DEFAULT_CREATION_OPTIONS={hints:["security-key"],authenticatorSelection:{authenticatorAttachment:"cross-platform",requireResidentKey:!1,userVerification:"preferred",residentKey:"discouraged"},attestation:"none"},DEFAULT_REQUEST_OPTIONS={userVerification:"preferred",hints:["security-key"]};function deepMerge(...sources){const isObject=val=>null!==val&&"object"==typeof val&&!Array.isArray(val),isArrayBufferLike=val=>val instanceof ArrayBuffer||ArrayBuffer.isView(val),result={};for(const source of sources)if(source)for(const key in source){const value=source[key];if(void 0!==value)if(Array.isArray(value))result[key]=value;else if(isArrayBufferLike(value))result[key]=value;else if(isObject(value)){const existing=result[key];isObject(existing)?result[key]=deepMerge(existing,value):result[key]=deepMerge(value)}else result[key]=value}return result}class WebAuthnApi{constructor(client){this.client=client,this.enroll=this._enroll.bind(this),this.challenge=this._challenge.bind(this),this.verify=this._verify.bind(this),this.authenticate=this._authenticate.bind(this),this.register=this._register.bind(this)}async _enroll(params){return this.client.mfa.enroll(Object.assign(Object.assign({},params),{factorType:"webauthn"}))}async _challenge({factorId,webauthn,friendlyName,signal},overrides){try{const{data:challengeResponse,error:challengeError}=await this.client.mfa.challenge({factorId,webauthn});if(!challengeResponse)return{data:null,error:challengeError};const abortSignal=null!=signal?signal:webAuthnAbortService.createNewAbortSignal();if("create"===challengeResponse.webauthn.type){const{user}=challengeResponse.webauthn.credential_options.publicKey;user.name||(user.name=`${user.id}:${friendlyName}`),user.displayName||(user.displayName=user.name)}switch(challengeResponse.webauthn.type){case"create":{const options=function mergeCredentialCreationOptions(baseOptions,overrides){return deepMerge(DEFAULT_CREATION_OPTIONS,baseOptions,overrides||{})}(challengeResponse.webauthn.credential_options.publicKey,null==overrides?void 0:overrides.create),{data,error}=await async function createCredential(options){try{const response=await navigator.credentials.create(options);return response?response instanceof PublicKeyCredential?{data:response,error:null}:{data:null,error:new WebAuthnUnknownError("Browser returned unexpected credential type",response)}:{data:null,error:new WebAuthnUnknownError("Empty credential response",response)}}catch(err){return{data:null,error:identifyRegistrationError({error:err,options})}}}({publicKey:options,signal:abortSignal});return data?{data:{factorId,challengeId:challengeResponse.id,webauthn:{type:challengeResponse.webauthn.type,credential_response:data}},error:null}:{data:null,error}}case"request":{const options=function mergeCredentialRequestOptions(baseOptions,overrides){return deepMerge(DEFAULT_REQUEST_OPTIONS,baseOptions,overrides||{})}(challengeResponse.webauthn.credential_options.publicKey,null==overrides?void 0:overrides.request),{data,error}=await async function getCredential(options){try{const response=await navigator.credentials.get(options);return response?response instanceof PublicKeyCredential?{data:response,error:null}:{data:null,error:new WebAuthnUnknownError("Browser returned unexpected credential type",response)}:{data:null,error:new WebAuthnUnknownError("Empty credential response",response)}}catch(err){return{data:null,error:identifyAuthenticationError({error:err,options})}}}(Object.assign(Object.assign({},challengeResponse.webauthn.credential_options),{publicKey:options,signal:abortSignal}));return data?{data:{factorId,challengeId:challengeResponse.id,webauthn:{type:challengeResponse.webauthn.type,credential_response:data}},error:null}:{data:null,error}}}}catch(error){return isAuthError(error)?{data:null,error}:{data:null,error:new AuthUnknownError("Unexpected error in challenge",error)}}}async _verify({challengeId,factorId,webauthn}){return this.client.mfa.verify({factorId,challengeId,webauthn})}async _authenticate({factorId,webauthn:{rpId="undefined"!=typeof window?window.location.hostname:void 0,rpOrigins="undefined"!=typeof window?[window.location.origin]:void 0,signal}},overrides){if(!rpId)return{data:null,error:new AuthError("rpId is required for WebAuthn authentication")};try{if(!browserSupportsWebAuthn())return{data:null,error:new AuthUnknownError("Browser does not support WebAuthn",null)};const{data:challengeResponse,error:challengeError}=await this.challenge({factorId,webauthn:{rpId,rpOrigins},signal},{request:overrides});if(!challengeResponse)return{data:null,error:challengeError};const{webauthn}=challengeResponse;return this._verify({factorId,challengeId:challengeResponse.challengeId,webauthn:{type:webauthn.type,rpId,rpOrigins,credential_response:webauthn.credential_response}})}catch(error){return isAuthError(error)?{data:null,error}:{data:null,error:new AuthUnknownError("Unexpected error in authenticate",error)}}}async _register({friendlyName,rpId="undefined"!=typeof window?window.location.hostname:void 0,rpOrigins="undefined"!=typeof window?[window.location.origin]:void 0,signal},overrides){if(!rpId)return{data:null,error:new AuthError("rpId is required for WebAuthn registration")};try{if(!browserSupportsWebAuthn())return{data:null,error:new AuthUnknownError("Browser does not support WebAuthn",null)};const{data:factor,error:enrollError}=await this._enroll({friendlyName});if(!factor)return await this.client.mfa.listFactors().then(factors=>{var _a;return null===(_a=factors.data)||void 0===_a?void 0:_a.all.find(v=>"webauthn"===v.factor_type&&v.friendly_name===friendlyName&&"unverified"!==v.status)}).then(factor=>factor?this.client.mfa.unenroll({factorId:null==factor?void 0:factor.id}):void 0),{data:null,error:enrollError};const{data:challengeResponse,error:challengeError}=await this._challenge({factorId:factor.id,friendlyName:factor.friendly_name,webauthn:{rpId,rpOrigins},signal},{create:overrides});return challengeResponse?this._verify({factorId:factor.id,challengeId:challengeResponse.challengeId,webauthn:{rpId,rpOrigins,type:challengeResponse.webauthn.type,credential_response:challengeResponse.webauthn.credential_response}}):{data:null,error:challengeError}}catch(error){return isAuthError(error)?{data:null,error}:{data:null,error:new AuthUnknownError("Unexpected error in register",error)}}}}var GoTrueClient_console=__webpack_require__("./node_modules/console-browserify/index.js");!function polyfillGlobalThis(){if("object"!=typeof globalThis)try{Object.defineProperty(Object.prototype,"__magic__",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__}catch(e){"undefined"!=typeof self&&(self.globalThis=self)}}();const DEFAULT_OPTIONS={url:"http://localhost:9999",storageKey:"supabase.auth.token",autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,headers:module_lib_constants_DEFAULT_HEADERS,flowType:"implicit",debug:!1,hasCustomAuthorizationHeader:!1,throwOnError:!1};async function lockNoOp(name,acquireTimeout,fn){return await fn()}const GLOBAL_JWKS={};class GoTrueClient{get jwks(){var _a,_b;return null!==(_b=null===(_a=GLOBAL_JWKS[this.storageKey])||void 0===_a?void 0:_a.jwks)&&void 0!==_b?_b:{keys:[]}}set jwks(value){GLOBAL_JWKS[this.storageKey]=Object.assign(Object.assign({},GLOBAL_JWKS[this.storageKey]),{jwks:value})}get jwks_cached_at(){var _a,_b;return null!==(_b=null===(_a=GLOBAL_JWKS[this.storageKey])||void 0===_a?void 0:_a.cachedAt)&&void 0!==_b?_b:Number.MIN_SAFE_INTEGER}set jwks_cached_at(value){GLOBAL_JWKS[this.storageKey]=Object.assign(Object.assign({},GLOBAL_JWKS[this.storageKey]),{cachedAt:value})}constructor(options){var _a,_b;this.userStorage=null,this.memoryStorage=null,this.stateChangeEmitters=new Map,this.autoRefreshTicker=null,this.visibilityChangedCallback=null,this.refreshingDeferred=null,this.initializePromise=null,this.detectSessionInUrl=!0,this.hasCustomAuthorizationHeader=!1,this.suppressGetSessionWarning=!1,this.lockAcquired=!1,this.pendingInLock=[],this.broadcastChannel=null,this.logger=GoTrueClient_console.log,this.instanceID=GoTrueClient.nextInstanceID,GoTrueClient.nextInstanceID+=1,this.instanceID>0&&helpers_isBrowser()&&GoTrueClient_console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");const settings=Object.assign(Object.assign({},DEFAULT_OPTIONS),options);if(this.logDebugMessages=!!settings.debug,"function"==typeof settings.debug&&(this.logger=settings.debug),this.persistSession=settings.persistSession,this.storageKey=settings.storageKey,this.autoRefreshToken=settings.autoRefreshToken,this.admin=new GoTrueAdminApi_GoTrueAdminApi({url:settings.url,headers:settings.headers,fetch:settings.fetch}),this.url=settings.url,this.headers=settings.headers,this.fetch=lib_helpers_resolveFetch(settings.fetch),this.lock=settings.lock||lockNoOp,this.detectSessionInUrl=settings.detectSessionInUrl,this.flowType=settings.flowType,this.hasCustomAuthorizationHeader=settings.hasCustomAuthorizationHeader,this.throwOnError=settings.throwOnError,settings.lock?this.lock=settings.lock:helpers_isBrowser()&&(null===(_a=null===globalThis||void 0===globalThis?void 0:globalThis.navigator)||void 0===_a?void 0:_a.locks)?this.lock=navigatorLock:this.lock=lockNoOp,this.jwks||(this.jwks={keys:[]},this.jwks_cached_at=Number.MIN_SAFE_INTEGER),this.mfa={verify:this._verify.bind(this),enroll:this._enroll.bind(this),unenroll:this._unenroll.bind(this),challenge:this._challenge.bind(this),listFactors:this._listFactors.bind(this),challengeAndVerify:this._challengeAndVerify.bind(this),getAuthenticatorAssuranceLevel:this._getAuthenticatorAssuranceLevel.bind(this),webauthn:new WebAuthnApi(this)},this.oauth={getAuthorizationDetails:this._getAuthorizationDetails.bind(this),approveAuthorization:this._approveAuthorization.bind(this),denyAuthorization:this._denyAuthorization.bind(this)},this.persistSession?(settings.storage?this.storage=settings.storage:supportsLocalStorage()?this.storage=globalThis.localStorage:(this.memoryStorage={},this.storage=memoryLocalStorageAdapter(this.memoryStorage)),settings.userStorage&&(this.userStorage=settings.userStorage)):(this.memoryStorage={},this.storage=memoryLocalStorageAdapter(this.memoryStorage)),helpers_isBrowser()&&globalThis.BroadcastChannel&&this.persistSession&&this.storageKey){try{this.broadcastChannel=new globalThis.BroadcastChannel(this.storageKey)}catch(e){GoTrueClient_console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available",e)}null===(_b=this.broadcastChannel)||void 0===_b||_b.addEventListener("message",async event=>{this._debug("received broadcast notification from other tab or client",event),await this._notifyAllSubscribers(event.data.event,event.data.session,!1)})}this.initialize()}isThrowOnErrorEnabled(){return this.throwOnError}_returnResult(result){if(this.throwOnError&&result&&result.error)throw result.error;return result}_debug(...args){return this.logDebugMessages&&this.logger(`GoTrueClient@${this.instanceID} (2.79.0) ${(new Date).toISOString()}`,...args),this}async initialize(){return this.initializePromise||(this.initializePromise=(async()=>await this._acquireLock(-1,async()=>await this._initialize()))()),await this.initializePromise}async _initialize(){var _a;try{let params={},callbackUrlType="none";if(helpers_isBrowser()&&(params=function parseParametersFromURL(href){const result={},url=new URL(href);if(url.hash&&"#"===url.hash[0])try{new URLSearchParams(url.hash.substring(1)).forEach((value,key)=>{result[key]=value})}catch(e){}return url.searchParams.forEach((value,key)=>{result[key]=value}),result}(window.location.href),this._isImplicitGrantCallback(params)?callbackUrlType="implicit":await this._isPKCECallback(params)&&(callbackUrlType="pkce")),helpers_isBrowser()&&this.detectSessionInUrl&&"none"!==callbackUrlType){const{data,error}=await this._getSessionFromURL(params,callbackUrlType);if(error){if(this._debug("#_initialize()","error detecting session from URL",error),function isAuthImplicitGrantRedirectError(error){return isAuthError(error)&&"AuthImplicitGrantRedirectError"===error.name}(error)){const errorCode=null===(_a=error.details)||void 0===_a?void 0:_a.code;if("identity_already_exists"===errorCode||"identity_not_found"===errorCode||"single_identity_not_deletable"===errorCode)return{error}}return await this._removeSession(),{error}}const{session,redirectType}=data;return this._debug("#_initialize()","detected session in URL",session,"redirect type",redirectType),await this._saveSession(session),setTimeout(async()=>{"recovery"===redirectType?await this._notifyAllSubscribers("PASSWORD_RECOVERY",session):await this._notifyAllSubscribers("SIGNED_IN",session)},0),{error:null}}return await this._recoverAndRefresh(),{error:null}}catch(error){return isAuthError(error)?this._returnResult({error}):this._returnResult({error:new AuthUnknownError("Unexpected error during initialization",error)})}finally{await this._handleVisibilityChange(),this._debug("#_initialize()","end")}}async signInAnonymously(credentials){var _a,_b,_c;try{const res=await _request(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{data:null!==(_b=null===(_a=null==credentials?void 0:credentials.options)||void 0===_a?void 0:_a.data)&&void 0!==_b?_b:{},gotrue_meta_security:{captcha_token:null===(_c=null==credentials?void 0:credentials.options)||void 0===_c?void 0:_c.captchaToken}},xform:_sessionResponse}),{data,error}=res;if(error||!data)return this._returnResult({data:{user:null,session:null},error});const session=data.session,user=data.user;return data.session&&(await this._saveSession(data.session),await this._notifyAllSubscribers("SIGNED_IN",session)),this._returnResult({data:{user,session},error:null})}catch(error){if(isAuthError(error))return this._returnResult({data:{user:null,session:null},error});throw error}}async signUp(credentials){var _a,_b,_c;try{let res;if("email"in credentials){const{email,password,options}=credentials;let codeChallenge=null,codeChallengeMethod=null;"pkce"===this.flowType&&([codeChallenge,codeChallengeMethod]=await getCodeChallengeAndMethod(this.storage,this.storageKey)),res=await _request(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,redirectTo:null==options?void 0:options.emailRedirectTo,body:{email,password,data:null!==(_a=null==options?void 0:options.data)&&void 0!==_a?_a:{},gotrue_meta_security:{captcha_token:null==options?void 0:options.captchaToken},code_challenge:codeChallenge,code_challenge_method:codeChallengeMethod},xform:_sessionResponse})}else{if(!("phone"in credentials))throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");{const{phone,password,options}=credentials;res=await _request(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{phone,password,data:null!==(_b=null==options?void 0:options.data)&&void 0!==_b?_b:{},channel:null!==(_c=null==options?void 0:options.channel)&&void 0!==_c?_c:"sms",gotrue_meta_security:{captcha_token:null==options?void 0:options.captchaToken}},xform:_sessionResponse})}}const{data,error}=res;if(error||!data)return this._returnResult({data:{user:null,session:null},error});const session=data.session,user=data.user;return data.session&&(await this._saveSession(data.session),await this._notifyAllSubscribers("SIGNED_IN",session)),this._returnResult({data:{user,session},error:null})}catch(error){if(isAuthError(error))return this._returnResult({data:{user:null,session:null},error});throw error}}async signInWithPassword(credentials){try{let res;if("email"in credentials){const{email,password,options}=credentials;res=await _request(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{email,password,gotrue_meta_security:{captcha_token:null==options?void 0:options.captchaToken}},xform:_sessionResponsePassword})}else{if(!("phone"in credentials))throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");{const{phone,password,options}=credentials;res=await _request(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{phone,password,gotrue_meta_security:{captcha_token:null==options?void 0:options.captchaToken}},xform:_sessionResponsePassword})}}const{data,error}=res;if(error)return this._returnResult({data:{user:null,session:null},error});if(!data||!data.session||!data.user){const invalidTokenError=new AuthInvalidTokenResponseError;return this._returnResult({data:{user:null,session:null},error:invalidTokenError})}return data.session&&(await this._saveSession(data.session),await this._notifyAllSubscribers("SIGNED_IN",data.session)),this._returnResult({data:Object.assign({user:data.user,session:data.session},data.weak_password?{weakPassword:data.weak_password}:null),error})}catch(error){if(isAuthError(error))return this._returnResult({data:{user:null,session:null},error});throw error}}async signInWithOAuth(credentials){var _a,_b,_c,_d;return await this._handleProviderSignIn(credentials.provider,{redirectTo:null===(_a=credentials.options)||void 0===_a?void 0:_a.redirectTo,scopes:null===(_b=credentials.options)||void 0===_b?void 0:_b.scopes,queryParams:null===(_c=credentials.options)||void 0===_c?void 0:_c.queryParams,skipBrowserRedirect:null===(_d=credentials.options)||void 0===_d?void 0:_d.skipBrowserRedirect})}async exchangeCodeForSession(authCode){return await this.initializePromise,this._acquireLock(-1,async()=>this._exchangeCodeForSession(authCode))}async signInWithWeb3(credentials){const{chain}=credentials;switch(chain){case"ethereum":return await this.signInWithEthereum(credentials);case"solana":return await this.signInWithSolana(credentials);default:throw new Error(`@supabase/auth-js: Unsupported chain "${chain}"`)}}async signInWithEthereum(credentials){var _a,_b,_c,_d,_e,_f,_g,_h,_j,_k,_l;let message,signature;if("message"in credentials)message=credentials.message,signature=credentials.signature;else{const{chain,wallet,statement,options}=credentials;let resolvedWallet;if(helpers_isBrowser())if("object"==typeof wallet)resolvedWallet=wallet;else{const windowAny=window;if(!("ethereum"in windowAny)||"object"!=typeof windowAny.ethereum||!("request"in windowAny.ethereum)||"function"!=typeof windowAny.ethereum.request)throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.");resolvedWallet=windowAny.ethereum}else{if("object"!=typeof wallet||!(null==options?void 0:options.url))throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");resolvedWallet=wallet}const url=new URL(null!==(_a=null==options?void 0:options.url)&&void 0!==_a?_a:window.location.href),accounts=await resolvedWallet.request({method:"eth_requestAccounts"}).then(accs=>accs).catch(()=>{throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid")});if(!accounts||0===accounts.length)throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");const address=getAddress(accounts[0]);let chainId=null===(_b=null==options?void 0:options.signInWithEthereum)||void 0===_b?void 0:_b.chainId;if(!chainId){chainId=function fromHex(hex){return parseInt(hex,16)}(await resolvedWallet.request({method:"eth_chainId"}))}message=function createSiweMessage(parameters){var _a;const{chainId,domain,expirationTime,issuedAt=new Date,nonce,notBefore,requestId,resources,scheme,uri,version}=parameters;if(!Number.isInteger(chainId))throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${chainId}`);if(!domain)throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');if(nonce&&nonce.length<8)throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${nonce}`);if(!uri)throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');if("1"!==version)throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${version}`);if(null===(_a=parameters.statement)||void 0===_a?void 0:_a.includes("\n"))throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${parameters.statement}`);const prefix=`${scheme?`${scheme}://${domain}`:domain} wants you to sign in with your Ethereum account:\n${getAddress(parameters.address)}\n\n${parameters.statement?`${parameters.statement}\n`:""}`;let suffix=`URI: ${uri}\nVersion: ${version}\nChain ID: ${chainId}${nonce?`\nNonce: ${nonce}`:""}\nIssued At: ${issuedAt.toISOString()}`;if(expirationTime&&(suffix+=`\nExpiration Time: ${expirationTime.toISOString()}`),notBefore&&(suffix+=`\nNot Before: ${notBefore.toISOString()}`),requestId&&(suffix+=`\nRequest ID: ${requestId}`),resources){let content="\nResources:";for(const resource of resources){if(!resource||"string"!=typeof resource)throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${resource}`);content+=`\n- ${resource}`}suffix+=content}return`${prefix}\n${suffix}`}({domain:url.host,address,statement,uri:url.href,version:"1",chainId,nonce:null===(_c=null==options?void 0:options.signInWithEthereum)||void 0===_c?void 0:_c.nonce,issuedAt:null!==(_e=null===(_d=null==options?void 0:options.signInWithEthereum)||void 0===_d?void 0:_d.issuedAt)&&void 0!==_e?_e:new Date,expirationTime:null===(_f=null==options?void 0:options.signInWithEthereum)||void 0===_f?void 0:_f.expirationTime,notBefore:null===(_g=null==options?void 0:options.signInWithEthereum)||void 0===_g?void 0:_g.notBefore,requestId:null===(_h=null==options?void 0:options.signInWithEthereum)||void 0===_h?void 0:_h.requestId,resources:null===(_j=null==options?void 0:options.signInWithEthereum)||void 0===_j?void 0:_j.resources}),signature=await resolvedWallet.request({method:"personal_sign",params:[toHex(message),address]})}try{const{data,error}=await _request(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"ethereum",message,signature},(null===(_k=credentials.options)||void 0===_k?void 0:_k.captchaToken)?{gotrue_meta_security:{captcha_token:null===(_l=credentials.options)||void 0===_l?void 0:_l.captchaToken}}:null),xform:_sessionResponse});if(error)throw error;if(!data||!data.session||!data.user){const invalidTokenError=new AuthInvalidTokenResponseError;return this._returnResult({data:{user:null,session:null},error:invalidTokenError})}return data.session&&(await this._saveSession(data.session),await this._notifyAllSubscribers("SIGNED_IN",data.session)),this._returnResult({data:Object.assign({},data),error})}catch(error){if(isAuthError(error))return this._returnResult({data:{user:null,session:null},error});throw error}}async signInWithSolana(credentials){var _a,_b,_c,_d,_e,_f,_g,_h,_j,_k,_l,_m;let message,signature;if("message"in credentials)message=credentials.message,signature=credentials.signature;else{const{chain,wallet,statement,options}=credentials;let resolvedWallet;if(helpers_isBrowser())if("object"==typeof wallet)resolvedWallet=wallet;else{const windowAny=window;if(!("solana"in windowAny)||"object"!=typeof windowAny.solana||!("signIn"in windowAny.solana&&"function"==typeof windowAny.solana.signIn||"signMessage"in windowAny.solana&&"function"==typeof windowAny.solana.signMessage))throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.");resolvedWallet=windowAny.solana}else{if("object"!=typeof wallet||!(null==options?void 0:options.url))throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");resolvedWallet=wallet}const url=new URL(null!==(_a=null==options?void 0:options.url)&&void 0!==_a?_a:window.location.href);if("signIn"in resolvedWallet&&resolvedWallet.signIn){const output=await resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({issuedAt:(new Date).toISOString()},null==options?void 0:options.signInWithSolana),{version:"1",domain:url.host,uri:url.href}),statement?{statement}:null));let outputToProcess;if(Array.isArray(output)&&output[0]&&"object"==typeof output[0])outputToProcess=output[0];else{if(!(output&&"object"==typeof output&&"signedMessage"in output&&"signature"in output))throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");outputToProcess=output}if(!("signedMessage"in outputToProcess&&"signature"in outputToProcess&&("string"==typeof outputToProcess.signedMessage||outputToProcess.signedMessage instanceof Uint8Array)&&outputToProcess.signature instanceof Uint8Array))throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields");message="string"==typeof outputToProcess.signedMessage?outputToProcess.signedMessage:(new TextDecoder).decode(outputToProcess.signedMessage),signature=outputToProcess.signature}else{if(!("signMessage"in resolvedWallet&&"function"==typeof resolvedWallet.signMessage&&"publicKey"in resolvedWallet&&"object"==typeof resolvedWallet&&resolvedWallet.publicKey&&"toBase58"in resolvedWallet.publicKey&&"function"==typeof resolvedWallet.publicKey.toBase58))throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");message=[`${url.host} wants you to sign in with your Solana account:`,resolvedWallet.publicKey.toBase58(),...statement?["",statement,""]:[""],"Version: 1",`URI: ${url.href}`,`Issued At: ${null!==(_c=null===(_b=null==options?void 0:options.signInWithSolana)||void 0===_b?void 0:_b.issuedAt)&&void 0!==_c?_c:(new Date).toISOString()}`,...(null===(_d=null==options?void 0:options.signInWithSolana)||void 0===_d?void 0:_d.notBefore)?[`Not Before: ${options.signInWithSolana.notBefore}`]:[],...(null===(_e=null==options?void 0:options.signInWithSolana)||void 0===_e?void 0:_e.expirationTime)?[`Expiration Time: ${options.signInWithSolana.expirationTime}`]:[],...(null===(_f=null==options?void 0:options.signInWithSolana)||void 0===_f?void 0:_f.chainId)?[`Chain ID: ${options.signInWithSolana.chainId}`]:[],...(null===(_g=null==options?void 0:options.signInWithSolana)||void 0===_g?void 0:_g.nonce)?[`Nonce: ${options.signInWithSolana.nonce}`]:[],...(null===(_h=null==options?void 0:options.signInWithSolana)||void 0===_h?void 0:_h.requestId)?[`Request ID: ${options.signInWithSolana.requestId}`]:[],...(null===(_k=null===(_j=null==options?void 0:options.signInWithSolana)||void 0===_j?void 0:_j.resources)||void 0===_k?void 0:_k.length)?["Resources",...options.signInWithSolana.resources.map(resource=>`- ${resource}`)]:[]].join("\n");const maybeSignature=await resolvedWallet.signMessage((new TextEncoder).encode(message),"utf8");if(!(maybeSignature&&maybeSignature instanceof Uint8Array))throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");signature=maybeSignature}}try{const{data,error}=await _request(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"solana",message,signature:bytesToBase64URL(signature)},(null===(_l=credentials.options)||void 0===_l?void 0:_l.captchaToken)?{gotrue_meta_security:{captcha_token:null===(_m=credentials.options)||void 0===_m?void 0:_m.captchaToken}}:null),xform:_sessionResponse});if(error)throw error;if(!data||!data.session||!data.user){const invalidTokenError=new AuthInvalidTokenResponseError;return this._returnResult({data:{user:null,session:null},error:invalidTokenError})}return data.session&&(await this._saveSession(data.session),await this._notifyAllSubscribers("SIGNED_IN",data.session)),this._returnResult({data:Object.assign({},data),error})}catch(error){if(isAuthError(error))return this._returnResult({data:{user:null,session:null},error});throw error}}async _exchangeCodeForSession(authCode){const storageItem=await getItemAsync(this.storage,`${this.storageKey}-code-verifier`),[codeVerifier,redirectType]=(null!=storageItem?storageItem:"").split("/");try{const{data,error}=await _request(this.fetch,"POST",`${this.url}/token?grant_type=pkce`,{headers:this.headers,body:{auth_code:authCode,code_verifier:codeVerifier},xform:_sessionResponse});if(await removeItemAsync(this.storage,`${this.storageKey}-code-verifier`),error)throw error;if(!data||!data.session||!data.user){const invalidTokenError=new AuthInvalidTokenResponseError;return this._returnResult({data:{user:null,session:null,redirectType:null},error:invalidTokenError})}return data.session&&(await this._saveSession(data.session),await this._notifyAllSubscribers("SIGNED_IN",data.session)),this._returnResult({data:Object.assign(Object.assign({},data),{redirectType:null!=redirectType?redirectType:null}),error})}catch(error){if(isAuthError(error))return this._returnResult({data:{user:null,session:null,redirectType:null},error});throw error}}async signInWithIdToken(credentials){try{const{options,provider,token,access_token,nonce}=credentials,res=await _request(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,body:{provider,id_token:token,access_token,nonce,gotrue_meta_security:{captcha_token:null==options?void 0:options.captchaToken}},xform:_sessionResponse}),{data,error}=res;if(error)return this._returnResult({data:{user:null,session:null},error});if(!data||!data.session||!data.user){const invalidTokenError=new AuthInvalidTokenResponseError;return this._returnResult({data:{user:null,session:null},error:invalidTokenError})}return data.session&&(await this._saveSession(data.session),await this._notifyAllSubscribers("SIGNED_IN",data.session)),this._returnResult({data,error})}catch(error){if(isAuthError(error))return this._returnResult({data:{user:null,session:null},error});throw error}}async signInWithOtp(credentials){var _a,_b,_c,_d,_e;try{if("email"in credentials){const{email,options}=credentials;let codeChallenge=null,codeChallengeMethod=null;"pkce"===this.flowType&&([codeChallenge,codeChallengeMethod]=await getCodeChallengeAndMethod(this.storage,this.storageKey));const{error}=await _request(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{email,data:null!==(_a=null==options?void 0:options.data)&&void 0!==_a?_a:{},create_user:null===(_b=null==options?void 0:options.shouldCreateUser)||void 0===_b||_b,gotrue_meta_security:{captcha_token:null==options?void 0:options.captchaToken},code_challenge:codeChallenge,code_challenge_method:codeChallengeMethod},redirectTo:null==options?void 0:options.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error})}if("phone"in credentials){const{phone,options}=credentials,{data,error}=await _request(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{phone,data:null!==(_c=null==options?void 0:options.data)&&void 0!==_c?_c:{},create_user:null===(_d=null==options?void 0:options.shouldCreateUser)||void 0===_d||_d,gotrue_meta_security:{captcha_token:null==options?void 0:options.captchaToken},channel:null!==(_e=null==options?void 0:options.channel)&&void 0!==_e?_e:"sms"}});return this._returnResult({data:{user:null,session:null,messageId:null==data?void 0:data.message_id},error})}throw new AuthInvalidCredentialsError("You must provide either an email or phone number.")}catch(error){if(isAuthError(error))return this._returnResult({data:{user:null,session:null},error});throw error}}async verifyOtp(params){var _a,_b;try{let redirectTo,captchaToken;"options"in params&&(redirectTo=null===(_a=params.options)||void 0===_a?void 0:_a.redirectTo,captchaToken=null===(_b=params.options)||void 0===_b?void 0:_b.captchaToken);const{data,error}=await _request(this.fetch,"POST",`${this.url}/verify`,{headers:this.headers,body:Object.assign(Object.assign({},params),{gotrue_meta_security:{captcha_token:captchaToken}}),redirectTo,xform:_sessionResponse});if(error)throw error;if(!data){throw new Error("An error occurred on token verification.")}const session=data.session,user=data.user;return(null==session?void 0:session.access_token)&&(await this._saveSession(session),await this._notifyAllSubscribers("recovery"==params.type?"PASSWORD_RECOVERY":"SIGNED_IN",session)),this._returnResult({data:{user,session},error:null})}catch(error){if(isAuthError(error))return this._returnResult({data:{user:null,session:null},error});throw error}}async signInWithSSO(params){var _a,_b,_c;try{let codeChallenge=null,codeChallengeMethod=null;"pkce"===this.flowType&&([codeChallenge,codeChallengeMethod]=await getCodeChallengeAndMethod(this.storage,this.storageKey));const result=await _request(this.fetch,"POST",`${this.url}/sso`,{body:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},"providerId"in params?{provider_id:params.providerId}:null),"domain"in params?{domain:params.domain}:null),{redirect_to:null!==(_b=null===(_a=params.options)||void 0===_a?void 0:_a.redirectTo)&&void 0!==_b?_b:void 0}),(null===(_c=null==params?void 0:params.options)||void 0===_c?void 0:_c.captchaToken)?{gotrue_meta_security:{captcha_token:params.options.captchaToken}}:null),{skip_http_redirect:!0,code_challenge:codeChallenge,code_challenge_method:codeChallengeMethod}),headers:this.headers,xform:_ssoResponse});return this._returnResult(result)}catch(error){if(isAuthError(error))return this._returnResult({data:null,error});throw error}}async reauthenticate(){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._reauthenticate())}async _reauthenticate(){try{return await this._useSession(async result=>{const{data:{session},error:sessionError}=result;if(sessionError)throw sessionError;if(!session)throw new AuthSessionMissingError;const{error}=await _request(this.fetch,"GET",`${this.url}/reauthenticate`,{headers:this.headers,jwt:session.access_token});return this._returnResult({data:{user:null,session:null},error})})}catch(error){if(isAuthError(error))return this._returnResult({data:{user:null,session:null},error});throw error}}async resend(credentials){try{const endpoint=`${this.url}/resend`;if("email"in credentials){const{email,type,options}=credentials,{error}=await _request(this.fetch,"POST",endpoint,{headers:this.headers,body:{email,type,gotrue_meta_security:{captcha_token:null==options?void 0:options.captchaToken}},redirectTo:null==options?void 0:options.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error})}if("phone"in credentials){const{phone,type,options}=credentials,{data,error}=await _request(this.fetch,"POST",endpoint,{headers:this.headers,body:{phone,type,gotrue_meta_security:{captcha_token:null==options?void 0:options.captchaToken}}});return this._returnResult({data:{user:null,session:null,messageId:null==data?void 0:data.message_id},error})}throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a type")}catch(error){if(isAuthError(error))return this._returnResult({data:{user:null,session:null},error});throw error}}async getSession(){await this.initializePromise;return await this._acquireLock(-1,async()=>this._useSession(async result=>result))}async _acquireLock(acquireTimeout,fn){this._debug("#_acquireLock","begin",acquireTimeout);try{if(this.lockAcquired){const last=this.pendingInLock.length?this.pendingInLock[this.pendingInLock.length-1]:Promise.resolve(),result=(async()=>(await last,await fn()))();return this.pendingInLock.push((async()=>{try{await result}catch(e){}})()),result}return await this.lock(`lock:${this.storageKey}`,acquireTimeout,async()=>{this._debug("#_acquireLock","lock acquired for storage key",this.storageKey);try{this.lockAcquired=!0;const result=fn();for(this.pendingInLock.push((async()=>{try{await result}catch(e){}})()),await result;this.pendingInLock.length;){const waitOn=[...this.pendingInLock];await Promise.all(waitOn),this.pendingInLock.splice(0,waitOn.length)}return await result}finally{this._debug("#_acquireLock","lock released for storage key",this.storageKey),this.lockAcquired=!1}})}finally{this._debug("#_acquireLock","end")}}async _useSession(fn){this._debug("#_useSession","begin");try{const result=await this.__loadSession();return await fn(result)}finally{this._debug("#_useSession","end")}}async __loadSession(){this._debug("#__loadSession()","begin"),this.lockAcquired||this._debug("#__loadSession()","used outside of an acquired lock!",(new Error).stack);try{let currentSession=null;const maybeSession=await getItemAsync(this.storage,this.storageKey);if(this._debug("#getSession()","session from storage",maybeSession),null!==maybeSession&&(this._isValidSession(maybeSession)?currentSession=maybeSession:(this._debug("#getSession()","session from storage is not valid"),await this._removeSession())),!currentSession)return{data:{session:null},error:null};const hasExpired=!!currentSession.expires_at&&1e3*currentSession.expires_at-Date.now()<9e4;if(this._debug("#__loadSession()",`session has${hasExpired?"":" not"} expired`,"expires_at",currentSession.expires_at),!hasExpired){if(this.userStorage){const maybeUser=await getItemAsync(this.userStorage,this.storageKey+"-user");(null==maybeUser?void 0:maybeUser.user)?currentSession.user=maybeUser.user:currentSession.user=userNotAvailableProxy()}if(this.storage.isServer&&currentSession.user&&!currentSession.user.__isUserNotAvailableProxy){const suppressWarningRef={value:this.suppressGetSessionWarning};currentSession.user=function insecureUserWarningProxy(user,suppressWarningRef){return new Proxy(user,{get:(target,prop,receiver)=>{if("__isInsecureUserWarningProxy"===prop)return!0;if("symbol"==typeof prop){const sProp=prop.toString();if("Symbol(Symbol.toPrimitive)"===sProp||"Symbol(Symbol.toStringTag)"===sProp||"Symbol(util.inspect.custom)"===sProp||"Symbol(nodejs.util.inspect.custom)"===sProp)return Reflect.get(target,prop,receiver)}return suppressWarningRef.value||"string"!=typeof prop||(helpers_console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),suppressWarningRef.value=!0),Reflect.get(target,prop,receiver)}})}(currentSession.user,suppressWarningRef),suppressWarningRef.value&&(this.suppressGetSessionWarning=!0)}return{data:{session:currentSession},error:null}}const{data:session,error}=await this._callRefreshToken(currentSession.refresh_token);return error?this._returnResult({data:{session:null},error}):this._returnResult({data:{session},error:null})}finally{this._debug("#__loadSession()","end")}}async getUser(jwt){if(jwt)return await this._getUser(jwt);await this.initializePromise;return await this._acquireLock(-1,async()=>await this._getUser())}async _getUser(jwt){try{return jwt?await _request(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt,xform:_userResponse}):await this._useSession(async result=>{var _a,_b,_c;const{data,error}=result;if(error)throw error;return(null===(_a=data.session)||void 0===_a?void 0:_a.access_token)||this.hasCustomAuthorizationHeader?await _request(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:null!==(_c=null===(_b=data.session)||void 0===_b?void 0:_b.access_token)&&void 0!==_c?_c:void 0,xform:_userResponse}):{data:{user:null},error:new AuthSessionMissingError}})}catch(error){if(isAuthError(error))return function isAuthSessionMissingError(error){return isAuthError(error)&&"AuthSessionMissingError"===error.name}(error)&&(await this._removeSession(),await removeItemAsync(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({data:{user:null},error});throw error}}async updateUser(attributes,options={}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._updateUser(attributes,options))}async _updateUser(attributes,options={}){try{return await this._useSession(async result=>{const{data:sessionData,error:sessionError}=result;if(sessionError)throw sessionError;if(!sessionData.session)throw new AuthSessionMissingError;const session=sessionData.session;let codeChallenge=null,codeChallengeMethod=null;"pkce"===this.flowType&&null!=attributes.email&&([codeChallenge,codeChallengeMethod]=await getCodeChallengeAndMethod(this.storage,this.storageKey));const{data,error:userError}=await _request(this.fetch,"PUT",`${this.url}/user`,{headers:this.headers,redirectTo:null==options?void 0:options.emailRedirectTo,body:Object.assign(Object.assign({},attributes),{code_challenge:codeChallenge,code_challenge_method:codeChallengeMethod}),jwt:session.access_token,xform:_userResponse});if(userError)throw userError;return session.user=data.user,await this._saveSession(session),await this._notifyAllSubscribers("USER_UPDATED",session),this._returnResult({data:{user:session.user},error:null})})}catch(error){if(isAuthError(error))return this._returnResult({data:{user:null},error});throw error}}async setSession(currentSession){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._setSession(currentSession))}async _setSession(currentSession){try{if(!currentSession.access_token||!currentSession.refresh_token)throw new AuthSessionMissingError;const timeNow=Date.now()/1e3;let expiresAt=timeNow,hasExpired=!0,session=null;const{payload}=decodeJWT(currentSession.access_token);if(payload.exp&&(expiresAt=payload.exp,hasExpired=expiresAt<=timeNow),hasExpired){const{data:refreshedSession,error}=await this._callRefreshToken(currentSession.refresh_token);if(error)return this._returnResult({data:{user:null,session:null},error});if(!refreshedSession)return{data:{user:null,session:null},error:null};session=refreshedSession}else{const{data,error}=await this._getUser(currentSession.access_token);if(error)throw error;session={access_token:currentSession.access_token,refresh_token:currentSession.refresh_token,user:data.user,token_type:"bearer",expires_in:expiresAt-timeNow,expires_at:expiresAt},await this._saveSession(session),await this._notifyAllSubscribers("SIGNED_IN",session)}return this._returnResult({data:{user:session.user,session},error:null})}catch(error){if(isAuthError(error))return this._returnResult({data:{session:null,user:null},error});throw error}}async refreshSession(currentSession){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._refreshSession(currentSession))}async _refreshSession(currentSession){try{return await this._useSession(async result=>{var _a;if(!currentSession){const{data,error}=result;if(error)throw error;currentSession=null!==(_a=data.session)&&void 0!==_a?_a:void 0}if(!(null==currentSession?void 0:currentSession.refresh_token))throw new AuthSessionMissingError;const{data:session,error}=await this._callRefreshToken(currentSession.refresh_token);return error?this._returnResult({data:{user:null,session:null},error}):session?this._returnResult({data:{user:session.user,session},error:null}):this._returnResult({data:{user:null,session:null},error:null})})}catch(error){if(isAuthError(error))return this._returnResult({data:{user:null,session:null},error});throw error}}async _getSessionFromURL(params,callbackUrlType){try{if(!helpers_isBrowser())throw new AuthImplicitGrantRedirectError("No browser detected.");if(params.error||params.error_description||params.error_code)throw new AuthImplicitGrantRedirectError(params.error_description||"Error in URL with unspecified error_description",{error:params.error||"unspecified_error",code:params.error_code||"unspecified_code"});switch(callbackUrlType){case"implicit":if("pkce"===this.flowType)throw new AuthPKCEGrantCodeExchangeError("Not a valid PKCE flow url.");break;case"pkce":if("implicit"===this.flowType)throw new AuthImplicitGrantRedirectError("Not a valid implicit grant flow url.")}if("pkce"===callbackUrlType){if(this._debug("#_initialize()","begin","is PKCE flow",!0),!params.code)throw new AuthPKCEGrantCodeExchangeError("No code detected.");const{data,error}=await this._exchangeCodeForSession(params.code);if(error)throw error;const url=new URL(window.location.href);return url.searchParams.delete("code"),window.history.replaceState(window.history.state,"",url.toString()),{data:{session:data.session,redirectType:null},error:null}}const{provider_token,provider_refresh_token,access_token,refresh_token,expires_in,expires_at,token_type}=params;if(!(access_token&&expires_in&&refresh_token&&token_type))throw new AuthImplicitGrantRedirectError("No session defined in URL");const timeNow=Math.round(Date.now()/1e3),expiresIn=parseInt(expires_in);let expiresAt=timeNow+expiresIn;expires_at&&(expiresAt=parseInt(expires_at));const actuallyExpiresIn=expiresAt-timeNow;1e3*actuallyExpiresIn<=3e4&&GoTrueClient_console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);const issuedAt=expiresAt-expiresIn;timeNow-issuedAt>=120?GoTrueClient_console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale",issuedAt,expiresAt,timeNow):timeNow-issuedAt<0&&GoTrueClient_console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew",issuedAt,expiresAt,timeNow);const{data,error}=await this._getUser(access_token);if(error)throw error;const session={provider_token,provider_refresh_token,access_token,expires_in:expiresIn,expires_at:expiresAt,refresh_token,token_type,user:data.user};return window.location.hash="",this._debug("#_getSessionFromURL()","clearing window.location.hash"),this._returnResult({data:{session,redirectType:params.type},error:null})}catch(error){if(isAuthError(error))return this._returnResult({data:{session:null,redirectType:null},error});throw error}}_isImplicitGrantCallback(params){return Boolean(params.access_token||params.error_description)}async _isPKCECallback(params){const currentStorageContent=await getItemAsync(this.storage,`${this.storageKey}-code-verifier`);return!(!params.code||!currentStorageContent)}async signOut(options={scope:"global"}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._signOut(options))}async _signOut({scope}={scope:"global"}){return await this._useSession(async result=>{var _a;const{data,error:sessionError}=result;if(sessionError)return this._returnResult({error:sessionError});const accessToken=null===(_a=data.session)||void 0===_a?void 0:_a.access_token;if(accessToken){const{error}=await this.admin.signOut(accessToken,scope);if(error&&(!function isAuthApiError(error){return isAuthError(error)&&"AuthApiError"===error.name}(error)||404!==error.status&&401!==error.status&&403!==error.status))return this._returnResult({error})}return"others"!==scope&&(await this._removeSession(),await removeItemAsync(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({error:null})})}onAuthStateChange(callback){const id=function helpers_uuid(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(c){const r=16*Math.random()|0;return("x"==c?r:3&r|8).toString(16)})}(),subscription={id,callback,unsubscribe:()=>{this._debug("#unsubscribe()","state change callback with id removed",id),this.stateChangeEmitters.delete(id)}};return this._debug("#onAuthStateChange()","registered callback with id",id),this.stateChangeEmitters.set(id,subscription),(async()=>{await this.initializePromise,await this._acquireLock(-1,async()=>{this._emitInitialSession(id)})})(),{data:{subscription}}}async _emitInitialSession(id){return await this._useSession(async result=>{var _a,_b;try{const{data:{session},error}=result;if(error)throw error;await(null===(_a=this.stateChangeEmitters.get(id))||void 0===_a?void 0:_a.callback("INITIAL_SESSION",session)),this._debug("INITIAL_SESSION","callback id",id,"session",session)}catch(err){await(null===(_b=this.stateChangeEmitters.get(id))||void 0===_b?void 0:_b.callback("INITIAL_SESSION",null)),this._debug("INITIAL_SESSION","callback id",id,"error",err),GoTrueClient_console.error(err)}})}async resetPasswordForEmail(email,options={}){let codeChallenge=null,codeChallengeMethod=null;"pkce"===this.flowType&&([codeChallenge,codeChallengeMethod]=await getCodeChallengeAndMethod(this.storage,this.storageKey,!0));try{return await _request(this.fetch,"POST",`${this.url}/recover`,{body:{email,code_challenge:codeChallenge,code_challenge_method:codeChallengeMethod,gotrue_meta_security:{captcha_token:options.captchaToken}},headers:this.headers,redirectTo:options.redirectTo})}catch(error){if(isAuthError(error))return this._returnResult({data:null,error});throw error}}async getUserIdentities(){var _a;try{const{data,error}=await this.getUser();if(error)throw error;return this._returnResult({data:{identities:null!==(_a=data.user.identities)&&void 0!==_a?_a:[]},error:null})}catch(error){if(isAuthError(error))return this._returnResult({data:null,error});throw error}}async linkIdentity(credentials){return"token"in credentials?this.linkIdentityIdToken(credentials):this.linkIdentityOAuth(credentials)}async linkIdentityOAuth(credentials){var _a;try{const{data,error}=await this._useSession(async result=>{var _a,_b,_c,_d,_e;const{data,error}=result;if(error)throw error;const url=await this._getUrlForProvider(`${this.url}/user/identities/authorize`,credentials.provider,{redirectTo:null===(_a=credentials.options)||void 0===_a?void 0:_a.redirectTo,scopes:null===(_b=credentials.options)||void 0===_b?void 0:_b.scopes,queryParams:null===(_c=credentials.options)||void 0===_c?void 0:_c.queryParams,skipBrowserRedirect:!0});return await _request(this.fetch,"GET",url,{headers:this.headers,jwt:null!==(_e=null===(_d=data.session)||void 0===_d?void 0:_d.access_token)&&void 0!==_e?_e:void 0})});if(error)throw error;return helpers_isBrowser()&&!(null===(_a=credentials.options)||void 0===_a?void 0:_a.skipBrowserRedirect)&&window.location.assign(null==data?void 0:data.url),this._returnResult({data:{provider:credentials.provider,url:null==data?void 0:data.url},error:null})}catch(error){if(isAuthError(error))return this._returnResult({data:{provider:credentials.provider,url:null},error});throw error}}async linkIdentityIdToken(credentials){return await this._useSession(async result=>{var _a;try{const{error:sessionError,data:{session}}=result;if(sessionError)throw sessionError;const{options,provider,token,access_token,nonce}=credentials,res=await _request(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,jwt:null!==(_a=null==session?void 0:session.access_token)&&void 0!==_a?_a:void 0,body:{provider,id_token:token,access_token,nonce,link_identity:!0,gotrue_meta_security:{captcha_token:null==options?void 0:options.captchaToken}},xform:_sessionResponse}),{data,error}=res;return error?this._returnResult({data:{user:null,session:null},error}):data&&data.session&&data.user?(data.session&&(await this._saveSession(data.session),await this._notifyAllSubscribers("USER_UPDATED",data.session)),this._returnResult({data,error})):this._returnResult({data:{user:null,session:null},error:new AuthInvalidTokenResponseError})}catch(error){if(isAuthError(error))return this._returnResult({data:{user:null,session:null},error});throw error}})}async unlinkIdentity(identity){try{return await this._useSession(async result=>{var _a,_b;const{data,error}=result;if(error)throw error;return await _request(this.fetch,"DELETE",`${this.url}/user/identities/${identity.identity_id}`,{headers:this.headers,jwt:null!==(_b=null===(_a=data.session)||void 0===_a?void 0:_a.access_token)&&void 0!==_b?_b:void 0})})}catch(error){if(isAuthError(error))return this._returnResult({data:null,error});throw error}}async _refreshAccessToken(refreshToken){const debugName=`#_refreshAccessToken(${refreshToken.substring(0,5)}...)`;this._debug(debugName,"begin");try{const startedAt=Date.now();return await function retryable(fn,isRetryable){return new Promise((accept,reject)=>{(async()=>{for(let attempt=0;attempt<1/0;attempt++)try{const result=await fn(attempt);if(!isRetryable(attempt,null,result))return void accept(result)}catch(e){if(!isRetryable(attempt,e))return void reject(e)}})()})}(async attempt=>(attempt>0&&await async function sleep(time){return await new Promise(accept=>{setTimeout(()=>accept(null),time)})}(200*Math.pow(2,attempt-1)),this._debug(debugName,"refreshing attempt",attempt),await _request(this.fetch,"POST",`${this.url}/token?grant_type=refresh_token`,{body:{refresh_token:refreshToken},headers:this.headers,xform:_sessionResponse})),(attempt,error)=>{const nextBackOffInterval=200*Math.pow(2,attempt);return error&&isAuthRetryableFetchError(error)&&Date.now()+nextBackOffInterval-startedAt<3e4})}catch(error){if(this._debug(debugName,"error",error),isAuthError(error))return this._returnResult({data:{session:null,user:null},error});throw error}finally{this._debug(debugName,"end")}}_isValidSession(maybeSession){return"object"==typeof maybeSession&&null!==maybeSession&&"access_token"in maybeSession&&"refresh_token"in maybeSession&&"expires_at"in maybeSession}async _handleProviderSignIn(provider,options){const url=await this._getUrlForProvider(`${this.url}/authorize`,provider,{redirectTo:options.redirectTo,scopes:options.scopes,queryParams:options.queryParams});return this._debug("#_handleProviderSignIn()","provider",provider,"options",options,"url",url),helpers_isBrowser()&&!options.skipBrowserRedirect&&window.location.assign(url),{data:{provider,url},error:null}}async _recoverAndRefresh(){var _a,_b;const debugName="#_recoverAndRefresh()";this._debug(debugName,"begin");try{const currentSession=await getItemAsync(this.storage,this.storageKey);if(currentSession&&this.userStorage){let maybeUser=await getItemAsync(this.userStorage,this.storageKey+"-user");this.storage.isServer||!Object.is(this.storage,this.userStorage)||maybeUser||(maybeUser={user:currentSession.user},await setItemAsync(this.userStorage,this.storageKey+"-user",maybeUser)),currentSession.user=null!==(_a=null==maybeUser?void 0:maybeUser.user)&&void 0!==_a?_a:userNotAvailableProxy()}else if(currentSession&&!currentSession.user&&!currentSession.user){const separateUser=await getItemAsync(this.storage,this.storageKey+"-user");separateUser&&(null==separateUser?void 0:separateUser.user)?(currentSession.user=separateUser.user,await removeItemAsync(this.storage,this.storageKey+"-user"),await setItemAsync(this.storage,this.storageKey,currentSession)):currentSession.user=userNotAvailableProxy()}if(this._debug(debugName,"session from storage",currentSession),!this._isValidSession(currentSession))return this._debug(debugName,"session is not valid"),void(null!==currentSession&&await this._removeSession());const expiresWithMargin=1e3*(null!==(_b=currentSession.expires_at)&&void 0!==_b?_b:1/0)-Date.now()<9e4;if(this._debug(debugName,`session has${expiresWithMargin?"":" not"} expired with margin of 90000s`),expiresWithMargin){if(this.autoRefreshToken&&currentSession.refresh_token){const{error}=await this._callRefreshToken(currentSession.refresh_token);error&&(GoTrueClient_console.error(error),isAuthRetryableFetchError(error)||(this._debug(debugName,"refresh failed with a non-retryable error, removing the session",error),await this._removeSession()))}}else if(currentSession.user&&!0===currentSession.user.__isUserNotAvailableProxy)try{const{data,error:userError}=await this._getUser(currentSession.access_token);!userError&&(null==data?void 0:data.user)?(currentSession.user=data.user,await this._saveSession(currentSession),await this._notifyAllSubscribers("SIGNED_IN",currentSession)):this._debug(debugName,"could not get user data, skipping SIGNED_IN notification")}catch(getUserError){GoTrueClient_console.error("Error getting user data:",getUserError),this._debug(debugName,"error getting user data, skipping SIGNED_IN notification",getUserError)}else await this._notifyAllSubscribers("SIGNED_IN",currentSession)}catch(err){return this._debug(debugName,"error",err),void GoTrueClient_console.error(err)}finally{this._debug(debugName,"end")}}async _callRefreshToken(refreshToken){var _a,_b;if(!refreshToken)throw new AuthSessionMissingError;if(this.refreshingDeferred)return this.refreshingDeferred.promise;const debugName=`#_callRefreshToken(${refreshToken.substring(0,5)}...)`;this._debug(debugName,"begin");try{this.refreshingDeferred=new Deferred;const{data,error}=await this._refreshAccessToken(refreshToken);if(error)throw error;if(!data.session)throw new AuthSessionMissingError;await this._saveSession(data.session),await this._notifyAllSubscribers("TOKEN_REFRESHED",data.session);const result={data:data.session,error:null};return this.refreshingDeferred.resolve(result),result}catch(error){if(this._debug(debugName,"error",error),isAuthError(error)){const result={data:null,error};return isAuthRetryableFetchError(error)||await this._removeSession(),null===(_a=this.refreshingDeferred)||void 0===_a||_a.resolve(result),result}throw null===(_b=this.refreshingDeferred)||void 0===_b||_b.reject(error),error}finally{this.refreshingDeferred=null,this._debug(debugName,"end")}}async _notifyAllSubscribers(event,session,broadcast=!0){const debugName=`#_notifyAllSubscribers(${event})`;this._debug(debugName,"begin",session,`broadcast = ${broadcast}`);try{this.broadcastChannel&&broadcast&&this.broadcastChannel.postMessage({event,session});const errors=[],promises=Array.from(this.stateChangeEmitters.values()).map(async x=>{try{await x.callback(event,session)}catch(e){errors.push(e)}});if(await Promise.all(promises),errors.length>0){for(let i=0;i<errors.length;i+=1)GoTrueClient_console.error(errors[i]);throw errors[0]}}finally{this._debug(debugName,"end")}}async _saveSession(session){this._debug("#_saveSession()",session),this.suppressGetSessionWarning=!0;const sessionToProcess=Object.assign({},session),userIsProxy=sessionToProcess.user&&!0===sessionToProcess.user.__isUserNotAvailableProxy;if(this.userStorage){!userIsProxy&&sessionToProcess.user&&await setItemAsync(this.userStorage,this.storageKey+"-user",{user:sessionToProcess.user});const mainSessionData=Object.assign({},sessionToProcess);delete mainSessionData.user;const clonedMainSessionData=deepClone(mainSessionData);await setItemAsync(this.storage,this.storageKey,clonedMainSessionData)}else{const clonedSession=deepClone(sessionToProcess);await setItemAsync(this.storage,this.storageKey,clonedSession)}}async _removeSession(){this._debug("#_removeSession()"),await removeItemAsync(this.storage,this.storageKey),await removeItemAsync(this.storage,this.storageKey+"-code-verifier"),await removeItemAsync(this.storage,this.storageKey+"-user"),this.userStorage&&await removeItemAsync(this.userStorage,this.storageKey+"-user"),await this._notifyAllSubscribers("SIGNED_OUT",null)}_removeVisibilityChangedCallback(){this._debug("#_removeVisibilityChangedCallback()");const callback=this.visibilityChangedCallback;this.visibilityChangedCallback=null;try{callback&&helpers_isBrowser()&&(null===window||void 0===window?void 0:window.removeEventListener)&&window.removeEventListener("visibilitychange",callback)}catch(e){GoTrueClient_console.error("removing visibilitychange callback failed",e)}}async _startAutoRefresh(){await this._stopAutoRefresh(),this._debug("#_startAutoRefresh()");const ticker=setInterval(()=>this._autoRefreshTokenTick(),3e4);this.autoRefreshTicker=ticker,ticker&&"object"==typeof ticker&&"function"==typeof ticker.unref?ticker.unref():"undefined"!=typeof Deno&&"function"==typeof Deno.unrefTimer&&Deno.unrefTimer(ticker),setTimeout(async()=>{await this.initializePromise,await this._autoRefreshTokenTick()},0)}async _stopAutoRefresh(){this._debug("#_stopAutoRefresh()");const ticker=this.autoRefreshTicker;this.autoRefreshTicker=null,ticker&&clearInterval(ticker)}async startAutoRefresh(){this._removeVisibilityChangedCallback(),await this._startAutoRefresh()}async stopAutoRefresh(){this._removeVisibilityChangedCallback(),await this._stopAutoRefresh()}async _autoRefreshTokenTick(){this._debug("#_autoRefreshTokenTick()","begin");try{await this._acquireLock(0,async()=>{try{const now=Date.now();try{return await this._useSession(async result=>{const{data:{session}}=result;if(!session||!session.refresh_token||!session.expires_at)return void this._debug("#_autoRefreshTokenTick()","no session");const expiresInTicks=Math.floor((1e3*session.expires_at-now)/3e4);this._debug("#_autoRefreshTokenTick()",`access token expires in ${expiresInTicks} ticks, a tick lasts 30000ms, refresh threshold is 3 ticks`),expiresInTicks<=3&&await this._callRefreshToken(session.refresh_token)})}catch(e){GoTrueClient_console.error("Auto refresh tick failed with error. This is likely a transient error.",e)}}finally{this._debug("#_autoRefreshTokenTick()","end")}})}catch(e){if(!(e.isAcquireTimeout||e instanceof LockAcquireTimeoutError))throw e;this._debug("auto refresh token tick lock not available")}}async _handleVisibilityChange(){if(this._debug("#_handleVisibilityChange()"),!helpers_isBrowser()||!(null===window||void 0===window?void 0:window.addEventListener))return this.autoRefreshToken&&this.startAutoRefresh(),!1;try{this.visibilityChangedCallback=async()=>await this._onVisibilityChanged(!1),null===window||void 0===window||window.addEventListener("visibilitychange",this.visibilityChangedCallback),await this._onVisibilityChanged(!0)}catch(error){GoTrueClient_console.error("_handleVisibilityChange",error)}}async _onVisibilityChanged(calledFromInitialize){const methodName=`#_onVisibilityChanged(${calledFromInitialize})`;this._debug(methodName,"visibilityState",document.visibilityState),"visible"===document.visibilityState?(this.autoRefreshToken&&this._startAutoRefresh(),calledFromInitialize||(await this.initializePromise,await this._acquireLock(-1,async()=>{"visible"===document.visibilityState?await this._recoverAndRefresh():this._debug(methodName,"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting")}))):"hidden"===document.visibilityState&&this.autoRefreshToken&&this._stopAutoRefresh()}async _getUrlForProvider(url,provider,options){const urlParams=[`provider=${encodeURIComponent(provider)}`];if((null==options?void 0:options.redirectTo)&&urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`),(null==options?void 0:options.scopes)&&urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`),"pkce"===this.flowType){const[codeChallenge,codeChallengeMethod]=await getCodeChallengeAndMethod(this.storage,this.storageKey),flowParams=new URLSearchParams({code_challenge:`${encodeURIComponent(codeChallenge)}`,code_challenge_method:`${encodeURIComponent(codeChallengeMethod)}`});urlParams.push(flowParams.toString())}if(null==options?void 0:options.queryParams){const query=new URLSearchParams(options.queryParams);urlParams.push(query.toString())}return(null==options?void 0:options.skipBrowserRedirect)&&urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`),`${url}?${urlParams.join("&")}`}async _unenroll(params){try{return await this._useSession(async result=>{var _a;const{data:sessionData,error:sessionError}=result;return sessionError?this._returnResult({data:null,error:sessionError}):await _request(this.fetch,"DELETE",`${this.url}/factors/${params.factorId}`,{headers:this.headers,jwt:null===(_a=null==sessionData?void 0:sessionData.session)||void 0===_a?void 0:_a.access_token})})}catch(error){if(isAuthError(error))return this._returnResult({data:null,error});throw error}}async _enroll(params){try{return await this._useSession(async result=>{var _a,_b;const{data:sessionData,error:sessionError}=result;if(sessionError)return this._returnResult({data:null,error:sessionError});const body=Object.assign({friendly_name:params.friendlyName,factor_type:params.factorType},"phone"===params.factorType?{phone:params.phone}:"totp"===params.factorType?{issuer:params.issuer}:{}),{data,error}=await _request(this.fetch,"POST",`${this.url}/factors`,{body,headers:this.headers,jwt:null===(_a=null==sessionData?void 0:sessionData.session)||void 0===_a?void 0:_a.access_token});return error?this._returnResult({data:null,error}):("totp"===params.factorType&&"totp"===data.type&&(null===(_b=null==data?void 0:data.totp)||void 0===_b?void 0:_b.qr_code)&&(data.totp.qr_code=`data:image/svg+xml;utf-8,${data.totp.qr_code}`),this._returnResult({data,error:null}))})}catch(error){if(isAuthError(error))return this._returnResult({data:null,error});throw error}}async _verify(params){return this._acquireLock(-1,async()=>{try{return await this._useSession(async result=>{var _a;const{data:sessionData,error:sessionError}=result;if(sessionError)return this._returnResult({data:null,error:sessionError});const body=Object.assign({challenge_id:params.challengeId},"webauthn"in params?{webauthn:Object.assign(Object.assign({},params.webauthn),{credential_response:"create"===params.webauthn.type?serializeCredentialCreationResponse(params.webauthn.credential_response):serializeCredentialRequestResponse(params.webauthn.credential_response)})}:{code:params.code}),{data,error}=await _request(this.fetch,"POST",`${this.url}/factors/${params.factorId}/verify`,{body,headers:this.headers,jwt:null===(_a=null==sessionData?void 0:sessionData.session)||void 0===_a?void 0:_a.access_token});return error?this._returnResult({data:null,error}):(await this._saveSession(Object.assign({expires_at:Math.round(Date.now()/1e3)+data.expires_in},data)),await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED",data),this._returnResult({data,error}))})}catch(error){if(isAuthError(error))return this._returnResult({data:null,error});throw error}})}async _challenge(params){return this._acquireLock(-1,async()=>{try{return await this._useSession(async result=>{var _a;const{data:sessionData,error:sessionError}=result;if(sessionError)return this._returnResult({data:null,error:sessionError});const response=await _request(this.fetch,"POST",`${this.url}/factors/${params.factorId}/challenge`,{body:params,headers:this.headers,jwt:null===(_a=null==sessionData?void 0:sessionData.session)||void 0===_a?void 0:_a.access_token});if(response.error)return response;const{data}=response;if("webauthn"!==data.type)return{data,error:null};switch(data.webauthn.type){case"create":return{data:Object.assign(Object.assign({},data),{webauthn:Object.assign(Object.assign({},data.webauthn),{credential_options:Object.assign(Object.assign({},data.webauthn.credential_options),{publicKey:deserializeCredentialCreationOptions(data.webauthn.credential_options.publicKey)})})}),error:null};case"request":return{data:Object.assign(Object.assign({},data),{webauthn:Object.assign(Object.assign({},data.webauthn),{credential_options:Object.assign(Object.assign({},data.webauthn.credential_options),{publicKey:deserializeCredentialRequestOptions(data.webauthn.credential_options.publicKey)})})}),error:null}}})}catch(error){if(isAuthError(error))return this._returnResult({data:null,error});throw error}})}async _challengeAndVerify(params){const{data:challengeData,error:challengeError}=await this._challenge({factorId:params.factorId});return challengeError?this._returnResult({data:null,error:challengeError}):await this._verify({factorId:params.factorId,challengeId:challengeData.id,code:params.code})}async _listFactors(){var _a;const{data:{user},error:userError}=await this.getUser();if(userError)return{data:null,error:userError};const data={all:[],phone:[],totp:[],webauthn:[]};for(const factor of null!==(_a=null==user?void 0:user.factors)&&void 0!==_a?_a:[])data.all.push(factor),"verified"===factor.status&&data[factor.factor_type].push(factor);return{data,error:null}}async _getAuthenticatorAssuranceLevel(){var _a,_b;const{data:{session},error:sessionError}=await this.getSession();if(sessionError)return this._returnResult({data:null,error:sessionError});if(!session)return{data:{currentLevel:null,nextLevel:null,currentAuthenticationMethods:[]},error:null};const{payload}=decodeJWT(session.access_token);let currentLevel=null;payload.aal&&(currentLevel=payload.aal);let nextLevel=currentLevel;(null!==(_b=null===(_a=session.user.factors)||void 0===_a?void 0:_a.filter(factor=>"verified"===factor.status))&&void 0!==_b?_b:[]).length>0&&(nextLevel="aal2");return{data:{currentLevel,nextLevel,currentAuthenticationMethods:payload.amr||[]},error:null}}async _getAuthorizationDetails(authorizationId){try{return await this._useSession(async result=>{const{data:{session},error:sessionError}=result;return sessionError?this._returnResult({data:null,error:sessionError}):session?await _request(this.fetch,"GET",`${this.url}/oauth/authorizations/${authorizationId}`,{headers:this.headers,jwt:session.access_token,xform:data=>({data,error:null})}):this._returnResult({data:null,error:new AuthSessionMissingError})})}catch(error){if(isAuthError(error))return this._returnResult({data:null,error});throw error}}async _approveAuthorization(authorizationId,options){try{return await this._useSession(async result=>{const{data:{session},error:sessionError}=result;if(sessionError)return this._returnResult({data:null,error:sessionError});if(!session)return this._returnResult({data:null,error:new AuthSessionMissingError});const response=await _request(this.fetch,"POST",`${this.url}/oauth/authorizations/${authorizationId}/consent`,{headers:this.headers,jwt:session.access_token,body:{action:"approve"},xform:data=>({data,error:null})});return response.data&&response.data.redirect_url&&helpers_isBrowser()&&!(null==options?void 0:options.skipBrowserRedirect)&&window.location.assign(response.data.redirect_url),response})}catch(error){if(isAuthError(error))return this._returnResult({data:null,error});throw error}}async _denyAuthorization(authorizationId,options){try{return await this._useSession(async result=>{const{data:{session},error:sessionError}=result;if(sessionError)return this._returnResult({data:null,error:sessionError});if(!session)return this._returnResult({data:null,error:new AuthSessionMissingError});const response=await _request(this.fetch,"POST",`${this.url}/oauth/authorizations/${authorizationId}/consent`,{headers:this.headers,jwt:session.access_token,body:{action:"deny"},xform:data=>({data,error:null})});return response.data&&response.data.redirect_url&&helpers_isBrowser()&&!(null==options?void 0:options.skipBrowserRedirect)&&window.location.assign(response.data.redirect_url),response})}catch(error){if(isAuthError(error))return this._returnResult({data:null,error});throw error}}async fetchJwk(kid,jwks={keys:[]}){let jwk=jwks.keys.find(key=>key.kid===kid);if(jwk)return jwk;const now=Date.now();if(jwk=this.jwks.keys.find(key=>key.kid===kid),jwk&&this.jwks_cached_at+6e5>now)return jwk;const{data,error}=await _request(this.fetch,"GET",`${this.url}/.well-known/jwks.json`,{headers:this.headers});if(error)throw error;return data.keys&&0!==data.keys.length?(this.jwks=data,this.jwks_cached_at=now,jwk=data.keys.find(key=>key.kid===kid),jwk||null):null}async getClaims(jwt,options={}){try{let token=jwt;if(!token){const{data,error}=await this.getSession();if(error||!data.session)return this._returnResult({data:null,error});token=data.session.access_token}const{header,payload,signature,raw:{header:rawHeader,payload:rawPayload}}=decodeJWT(token);(null==options?void 0:options.allowExpired)||function validateExp(exp){if(!exp)throw new Error("Missing exp claim");if(exp<=Math.floor(Date.now()/1e3))throw new Error("JWT has expired")}(payload.exp);const signingKey=header.alg&&!header.alg.startsWith("HS")&&header.kid&&"crypto"in globalThis&&"subtle"in globalThis.crypto?await this.fetchJwk(header.kid,(null==options?void 0:options.keys)?{keys:options.keys}:null==options?void 0:options.jwks):null;if(!signingKey){const{error}=await this.getUser(token);if(error)throw error;return{data:{claims:payload,header,signature},error:null}}const algorithm=function getAlgorithm(alg){switch(alg){case"RS256":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"ES256":return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};default:throw new Error("Invalid alg claim")}}(header.alg),publicKey=await crypto.subtle.importKey("jwk",signingKey,algorithm,!0,["verify"]);if(!await crypto.subtle.verify(algorithm,publicKey,signature,function stringToUint8Array(str){const result=[];return stringToUTF8(str,byte=>result.push(byte)),new Uint8Array(result)}(`${rawHeader}.${rawPayload}`)))throw new AuthInvalidJwtError("Invalid JWT signature");return{data:{claims:payload,header,signature},error:null}}catch(error){if(isAuthError(error))return this._returnResult({data:null,error});throw error}}}GoTrueClient.nextInstanceID=0;const module_AuthClient=GoTrueClient;class SupabaseAuthClient extends module_AuthClient{constructor(options){super(options)}}class SupabaseClient{constructor(supabaseUrl,supabaseKey,options){var _a,_b,_c;this.supabaseUrl=supabaseUrl,this.supabaseKey=supabaseKey;const baseUrl=function validateSupabaseUrl(supabaseUrl){const trimmedUrl=null==supabaseUrl?void 0:supabaseUrl.trim();if(!trimmedUrl)throw new Error("supabaseUrl is required.");if(!trimmedUrl.match(/^https?:\/\//i))throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");try{return new URL(function ensureTrailingSlash(url){return url.endsWith("/")?url:url+"/"}(trimmedUrl))}catch(_a){throw Error("Invalid supabaseUrl: Provided URL is malformed.")}}(supabaseUrl);if(!supabaseKey)throw new Error("supabaseKey is required.");this.realtimeUrl=new URL("realtime/v1",baseUrl),this.realtimeUrl.protocol=this.realtimeUrl.protocol.replace("http","ws"),this.authUrl=new URL("auth/v1",baseUrl),this.storageUrl=new URL("storage/v1",baseUrl),this.functionsUrl=new URL("functions/v1",baseUrl);const defaultStorageKey=`sb-${baseUrl.hostname.split(".")[0]}-auth-token`,settings=function applySettingDefaults(options,defaults){var _a,_b;const{db:dbOptions,auth:authOptions,realtime:realtimeOptions,global:globalOptions}=options,{db:DEFAULT_DB_OPTIONS,auth:DEFAULT_AUTH_OPTIONS,realtime:DEFAULT_REALTIME_OPTIONS,global:DEFAULT_GLOBAL_OPTIONS}=defaults,result={db:Object.assign(Object.assign({},DEFAULT_DB_OPTIONS),dbOptions),auth:Object.assign(Object.assign({},DEFAULT_AUTH_OPTIONS),authOptions),realtime:Object.assign(Object.assign({},DEFAULT_REALTIME_OPTIONS),realtimeOptions),storage:{},global:Object.assign(Object.assign(Object.assign({},DEFAULT_GLOBAL_OPTIONS),globalOptions),{headers:Object.assign(Object.assign({},null!==(_a=null==DEFAULT_GLOBAL_OPTIONS?void 0:DEFAULT_GLOBAL_OPTIONS.headers)&&void 0!==_a?_a:{}),null!==(_b=null==globalOptions?void 0:globalOptions.headers)&&void 0!==_b?_b:{})}),accessToken:async()=>""};return options.accessToken?result.accessToken=options.accessToken:delete result.accessToken,result}(null!=options?options:{},{db:DEFAULT_DB_OPTIONS,realtime:DEFAULT_REALTIME_OPTIONS,auth:Object.assign(Object.assign({},DEFAULT_AUTH_OPTIONS),{storageKey:defaultStorageKey}),global:DEFAULT_GLOBAL_OPTIONS});this.storageKey=null!==(_a=settings.auth.storageKey)&&void 0!==_a?_a:"",this.headers=null!==(_b=settings.global.headers)&&void 0!==_b?_b:{},settings.accessToken?(this.accessToken=settings.accessToken,this.auth=new Proxy({},{get:(_,prop)=>{throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`)}})):this.auth=this._initSupabaseAuthClient(null!==(_c=settings.auth)&&void 0!==_c?_c:{},this.headers,settings.global.fetch),this.fetch=fetchWithAuth(supabaseKey,this._getAccessToken.bind(this),settings.global.fetch),this.realtime=this._initRealtimeClient(Object.assign({headers:this.headers,accessToken:this._getAccessToken.bind(this)},settings.realtime)),this.rest=new PostgrestClient(new URL("rest/v1",baseUrl).href,{headers:this.headers,schema:settings.db.schema,fetch:this.fetch}),this.storage=new StorageClient(this.storageUrl.href,this.headers,this.fetch,null==options?void 0:options.storage),settings.accessToken||this._listenForAuthEvents()}get functions(){return new FunctionsClient(this.functionsUrl.href,{headers:this.headers,customFetch:this.fetch})}from(relation){return this.rest.from(relation)}schema(schema){return this.rest.schema(schema)}rpc(fn,args={},options={head:!1,get:!1,count:void 0}){return this.rest.rpc(fn,args,options)}channel(name,opts={config:{}}){return this.realtime.channel(name,opts)}getChannels(){return this.realtime.getChannels()}removeChannel(channel){return this.realtime.removeChannel(channel)}removeAllChannels(){return this.realtime.removeAllChannels()}async _getAccessToken(){var _a,_b;if(this.accessToken)return await this.accessToken();const{data}=await this.auth.getSession();return null!==(_b=null===(_a=data.session)||void 0===_a?void 0:_a.access_token)&&void 0!==_b?_b:this.supabaseKey}_initSupabaseAuthClient({autoRefreshToken,persistSession,detectSessionInUrl,storage,userStorage,storageKey,flowType,lock,debug,throwOnError},headers,fetch){const authHeaders={Authorization:`Bearer ${this.supabaseKey}`,apikey:`${this.supabaseKey}`};return new SupabaseAuthClient({url:this.authUrl.href,headers:Object.assign(Object.assign({},authHeaders),headers),storageKey,autoRefreshToken,persistSession,detectSessionInUrl,storage,userStorage,flowType,lock,debug,throwOnError,fetch,hasCustomAuthorizationHeader:Object.keys(this.headers).some(key=>"authorization"===key.toLowerCase())})}_initRealtimeClient(options){return new RealtimeClient(this.realtimeUrl.href,Object.assign(Object.assign({},options),{params:Object.assign({apikey:this.supabaseKey},null==options?void 0:options.params)}))}_listenForAuthEvents(){return this.auth.onAuthStateChange((event,session)=>{this._handleTokenChanged(event,"CLIENT",null==session?void 0:session.access_token)})}_handleTokenChanged(event,source,token){"TOKEN_REFRESHED"!==event&&"SIGNED_IN"!==event||this.changedAccessToken===token?"SIGNED_OUT"===event&&(this.realtime.setAuth(),"STORAGE"==source&&this.auth.signOut(),this.changedAccessToken=void 0):(this.changedAccessToken=token,this.realtime.setAuth(token))}}var module_process=__webpack_require__("./node_modules/process/browser.js"),module_console=__webpack_require__("./node_modules/console-browserify/index.js");const createClient=(supabaseUrl,supabaseKey,options)=>new SupabaseClient(supabaseUrl,supabaseKey,options);(function shouldShowDeprecationWarning(){if("undefined"!=typeof window)return!1;if(void 0===module_process)return!1;const processVersion=module_process.version;if(null==processVersion)return!1;const versionMatch=processVersion.match(/^v(\d+)\./);return!!versionMatch&&parseInt(versionMatch[1],10)<=18})()&&module_console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");const version_VERSION="0.7.0";var dist=__webpack_require__("./node_modules/cookie/dist/index.js");function utils_helpers_isBrowser(){return"undefined"!=typeof window&&void 0!==window.document}const DEFAULT_COOKIE_OPTIONS={path:"/",sameSite:"lax",httpOnly:!1,maxAge:3456e4},MAX_CHUNK_SIZE=3180,CHUNK_LIKE_REGEX=/^(.*)[.](0|[1-9][0-9]*)$/;function isChunkLike(cookieName,key){if(cookieName===key)return!0;const chunkLike=cookieName.match(CHUNK_LIKE_REGEX);return!(!chunkLike||chunkLike[1]!==key)}function createChunks(key,value,chunkSize){const resolvedChunkSize=chunkSize??MAX_CHUNK_SIZE;let encodedValue=encodeURIComponent(value);if(encodedValue.length<=resolvedChunkSize)return[{name:key,value}];const chunks=[];for(;encodedValue.length>0;){let encodedChunkHead=encodedValue.slice(0,resolvedChunkSize);const lastEscapePos=encodedChunkHead.lastIndexOf("%");lastEscapePos>resolvedChunkSize-3&&(encodedChunkHead=encodedChunkHead.slice(0,lastEscapePos));let valueHead="";for(;encodedChunkHead.length>0;)try{valueHead=decodeURIComponent(encodedChunkHead);break}catch(error){if(!(error instanceof URIError&&"%"===encodedChunkHead.at(-3)&&encodedChunkHead.length>3))throw error;encodedChunkHead=encodedChunkHead.slice(0,encodedChunkHead.length-3)}chunks.push(valueHead),encodedValue=encodedValue.slice(encodedChunkHead.length)}return chunks.map((value,i)=>({name:`${key}.${i}`,value}))}async function combineChunks(key,retrieveChunk){const value=await retrieveChunk(key);if(value)return value;let values=[];for(let i=0;;i++){const chunkName=`${key}.${i}`,chunk=await retrieveChunk(chunkName);if(!chunk)break;values.push(chunk)}return values.length>0?values.join(""):null}const base64url_TO_BASE64URL="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""),base64url_IGNORE_BASE64URL=" \t\n\r=".split(""),base64url_FROM_BASE64URL=(()=>{const charMap=new Array(128);for(let i=0;i<charMap.length;i+=1)charMap[i]=-1;for(let i=0;i<base64url_IGNORE_BASE64URL.length;i+=1)charMap[base64url_IGNORE_BASE64URL[i].charCodeAt(0)]=-2;for(let i=0;i<base64url_TO_BASE64URL.length;i+=1)charMap[base64url_TO_BASE64URL[i].charCodeAt(0)]=i;return charMap})();function base64url_stringToBase64URL(str){const base64=[];let queue=0,queuedBits=0;if(function base64url_stringToUTF8(str,emit){for(let i=0;i<str.length;i+=1){let codepoint=str.charCodeAt(i);if(codepoint>55295&&codepoint<=56319){const highSurrogate=1024*(codepoint-55296)&65535;codepoint=65536+(str.charCodeAt(i+1)-56320&65535|highSurrogate),i+=1}base64url_codepointToUTF8(codepoint,emit)}}(str,byte=>{for(queue=queue<<8|byte,queuedBits+=8;queuedBits>=6;){const pos=queue>>queuedBits-6&63;base64.push(base64url_TO_BASE64URL[pos]),queuedBits-=6}}),queuedBits>0)for(queue<<=6-queuedBits,queuedBits=6;queuedBits>=6;){const pos=queue>>queuedBits-6&63;base64.push(base64url_TO_BASE64URL[pos]),queuedBits-=6}return base64.join("")}function base64url_stringFromBase64URL(str){const conv=[],emit=codepoint=>{conv.push(String.fromCodePoint(codepoint))},state={utf8seq:0,codepoint:0};let queue=0,queuedBits=0;for(let i=0;i<str.length;i+=1){const codepoint=str.charCodeAt(i),bits=base64url_FROM_BASE64URL[codepoint];if(!(bits>-1)){if(-2===bits)continue;throw new Error(`Invalid Base64-URL character "${str.at(i)}" at position ${i}`)}for(queue=queue<<6|bits,queuedBits+=6;queuedBits>=8;)base64url_stringFromUTF8(queue>>queuedBits-8&255,state,emit),queuedBits-=8}return conv.join("")}function base64url_codepointToUTF8(codepoint,emit){if(!(codepoint<=127)){if(codepoint<=2047)return emit(192|codepoint>>6),void emit(128|63&codepoint);if(codepoint<=65535)return emit(224|codepoint>>12),emit(128|codepoint>>6&63),void emit(128|63&codepoint);if(codepoint<=1114111)return emit(240|codepoint>>18),emit(128|codepoint>>12&63),emit(128|codepoint>>6&63),void emit(128|63&codepoint);throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`)}emit(codepoint)}function base64url_stringFromUTF8(byte,state,emit){if(0===state.utf8seq){if(byte<=127)return void emit(byte);for(let leadingBit=1;leadingBit<6;leadingBit+=1)if(!(byte>>7-leadingBit&1)){state.utf8seq=leadingBit;break}if(2===state.utf8seq)state.codepoint=31&byte;else if(3===state.utf8seq)state.codepoint=15&byte;else{if(4!==state.utf8seq)throw new Error("Invalid UTF-8 sequence");state.codepoint=7&byte}state.utf8seq-=1}else if(state.utf8seq>0){if(byte<=127)throw new Error("Invalid UTF-8 sequence");state.codepoint=state.codepoint<<6|63&byte,state.utf8seq-=1,0===state.utf8seq&&emit(state.codepoint)}}var cookies_console=__webpack_require__("./node_modules/console-browserify/index.js");const BASE64_PREFIX="base64-";function createStorageFromOptions(options,isServerClient){const cookies=options.cookies??null,cookieEncoding=options.cookieEncoding,setItems={},removedItems={};let getAll,setAll;if(cookies)if("get"in cookies){const getWithHints=async keyHints=>{const chunkNames=keyHints.flatMap(keyHint=>[keyHint,...Array.from({length:5}).map((_,i)=>`${keyHint}.${i}`)]),chunks=[];for(let i=0;i<chunkNames.length;i+=1){const value=await cookies.get(chunkNames[i]);(value||"string"==typeof value)&&chunks.push({name:chunkNames[i],value})}return chunks};if(getAll=async keyHints=>await getWithHints(keyHints),"set"in cookies&&"remove"in cookies)setAll=async setCookies=>{for(let i=0;i<setCookies.length;i+=1){const{name,value,options}=setCookies[i];value?await cookies.set(name,value,options):await cookies.remove(name,options)}};else{if(!isServerClient)throw new Error("@supabase/ssr: createBrowserClient requires configuring a getAll and setAll cookie method (deprecated: alternatively both get, set and remove can be used)");setAll=async()=>{cookies_console.warn("@supabase/ssr: createServerClient was configured without set and remove cookie methods, but the client needs to set cookies. This can lead to issues such as random logouts, early session termination or increased token refresh requests. If in NextJS, check your middleware.ts file, route handlers and server actions for correctness. Consider switching to the getAll and setAll cookie methods instead of get, set and remove which are deprecated and can be difficult to use correctly.")}}}else{if(!("getAll"in cookies))throw new Error(`@supabase/ssr: ${isServerClient?"createServerClient":"createBrowserClient"} requires configuring getAll and setAll cookie methods (deprecated: alternatively use get, set and remove).${utils_helpers_isBrowser()?" As this is called in a browser runtime, consider removing the cookies option object to use the document.cookie API automatically.":""}`);if(getAll=async()=>await cookies.getAll(),"setAll"in cookies)setAll=cookies.setAll;else{if(!isServerClient)throw new Error("@supabase/ssr: createBrowserClient requires configuring both getAll and setAll cookie methods (deprecated: alternatively both get, set and remove can be used)");setAll=async()=>{cookies_console.warn("@supabase/ssr: createServerClient was configured without the setAll cookie method, but the client needs to set cookies. This can lead to issues such as random logouts, early session termination or increased token refresh requests. If in NextJS, check your middleware.ts file, route handlers and server actions for correctness.")}}}else if(!isServerClient&&utils_helpers_isBrowser()){const noHintGetAll=()=>{const parsed=(0,dist.qg)(document.cookie);return Object.keys(parsed).map(name=>({name,value:parsed[name]??""}))};getAll=()=>noHintGetAll(),setAll=setCookies=>{setCookies.forEach(({name,value,options})=>{document.cookie=(0,dist.lK)(name,value,options)})}}else{if(isServerClient)throw new Error("@supabase/ssr: createServerClient must be initialized with cookie options that specify getAll and setAll functions (deprecated, not recommended: alternatively use get, set and remove)");getAll=()=>[],setAll=()=>{throw new Error("@supabase/ssr: createBrowserClient in non-browser runtimes (including Next.js pre-rendering mode) was not initialized cookie options that specify getAll and setAll functions (deprecated: alternatively use get, set and remove), but they were needed")}}return isServerClient?{getAll,setAll,setItems,removedItems,storage:{isServer:!0,getItem:async key=>{if("string"==typeof setItems[key])return setItems[key];if(removedItems[key])return null;const allCookies=await getAll([key]),chunkedCookie=await combineChunks(key,async chunkName=>{const cookie=allCookies?.find(({name})=>name===chunkName)||null;return cookie?cookie.value:null});if(!chunkedCookie)return null;let decoded=chunkedCookie;return"string"==typeof chunkedCookie&&chunkedCookie.startsWith(BASE64_PREFIX)&&(decoded=base64url_stringFromBase64URL(chunkedCookie.substring(BASE64_PREFIX.length))),decoded},setItem:async(key,value)=>{key.endsWith("-code-verifier")&&await applyServerStorage({getAll,setAll,setItems:{[key]:value},removedItems:{}},{cookieOptions:options?.cookieOptions??null,cookieEncoding}),setItems[key]=value,delete removedItems[key]},removeItem:async key=>{delete setItems[key],removedItems[key]=!0}}}:{getAll,setAll,setItems,removedItems,storage:{isServer:!1,getItem:async key=>{const allCookies=await getAll([key]),chunkedCookie=await combineChunks(key,async chunkName=>{const cookie=allCookies?.find(({name})=>name===chunkName)||null;return cookie?cookie.value:null});if(!chunkedCookie)return null;let decoded=chunkedCookie;return chunkedCookie.startsWith(BASE64_PREFIX)&&(decoded=base64url_stringFromBase64URL(chunkedCookie.substring(BASE64_PREFIX.length))),decoded},setItem:async(key,value)=>{const allCookies=await getAll([key]),cookieNames=allCookies?.map(({name})=>name)||[],removeCookies=new Set(cookieNames.filter(name=>isChunkLike(name,key)));let encoded=value;"base64url"===cookieEncoding&&(encoded=BASE64_PREFIX+base64url_stringToBase64URL(value));const setCookies=createChunks(key,encoded);setCookies.forEach(({name})=>{removeCookies.delete(name)});const removeCookieOptions={...DEFAULT_COOKIE_OPTIONS,...options?.cookieOptions,maxAge:0},setCookieOptions={...DEFAULT_COOKIE_OPTIONS,...options?.cookieOptions,maxAge:DEFAULT_COOKIE_OPTIONS.maxAge};delete removeCookieOptions.name,delete setCookieOptions.name;const allToSet=[...[...removeCookies].map(name=>({name,value:"",options:removeCookieOptions})),...setCookies.map(({name,value})=>({name,value,options:setCookieOptions}))];allToSet.length>0&&await setAll(allToSet)},removeItem:async key=>{const allCookies=await getAll([key]),removeCookies=(allCookies?.map(({name})=>name)||[]).filter(name=>isChunkLike(name,key)),removeCookieOptions={...DEFAULT_COOKIE_OPTIONS,...options?.cookieOptions,maxAge:0};delete removeCookieOptions.name,removeCookies.length>0&&await setAll(removeCookies.map(name=>({name,value:"",options:removeCookieOptions})))}}}}async function applyServerStorage({getAll,setAll,setItems,removedItems},options){const cookieEncoding=options.cookieEncoding,cookieOptions=options.cookieOptions??null,allCookies=await getAll([...setItems?Object.keys(setItems):[],...removedItems?Object.keys(removedItems):[]]),cookieNames=allCookies?.map(({name})=>name)||[],removeCookies=Object.keys(removedItems).flatMap(itemName=>cookieNames.filter(name=>isChunkLike(name,itemName))),setCookies=Object.keys(setItems).flatMap(itemName=>{const removeExistingCookiesForItem=new Set(cookieNames.filter(name=>isChunkLike(name,itemName)));let encoded=setItems[itemName];"base64url"===cookieEncoding&&(encoded=BASE64_PREFIX+base64url_stringToBase64URL(encoded));const chunks=createChunks(itemName,encoded);return chunks.forEach(chunk=>{removeExistingCookiesForItem.delete(chunk.name)}),removeCookies.push(...removeExistingCookiesForItem),chunks}),removeCookieOptions={...DEFAULT_COOKIE_OPTIONS,...cookieOptions,maxAge:0},setCookieOptions={...DEFAULT_COOKIE_OPTIONS,...cookieOptions,maxAge:DEFAULT_COOKIE_OPTIONS.maxAge};delete removeCookieOptions.name,delete setCookieOptions.name,await setAll([...removeCookies.map(name=>({name,value:"",options:removeCookieOptions})),...setCookies.map(({name,value})=>({name,value,options:setCookieOptions}))])}let cachedBrowserClient;function createBrowserClient(supabaseUrl,supabaseKey,options){const shouldUseSingleton=!0===options?.isSingleton||(!options||!("isSingleton"in options))&&utils_helpers_isBrowser();if(shouldUseSingleton&&cachedBrowserClient)return cachedBrowserClient;if(!supabaseUrl||!supabaseKey)throw new Error("@supabase/ssr: Your project's URL and API key are required to create a Supabase client!\n\nCheck your Supabase project's API settings to find these values\n\nhttps://supabase.com/dashboard/project/_/settings/api");const{storage}=createStorageFromOptions({...options,cookieEncoding:options?.cookieEncoding??"base64url"},!1),client=createClient(supabaseUrl,supabaseKey,{...options,global:{...options?.global,headers:{...options?.global?.headers,"X-Client-Info":`supabase-ssr/${version_VERSION} createBrowserClient`}},auth:{...options?.auth,...options?.cookieOptions?.name?{storageKey:options.cookieOptions.name}:null,flowType:"pkce",autoRefreshToken:utils_helpers_isBrowser(),detectSessionInUrl:utils_helpers_isBrowser(),persistSession:!0,storage}});return shouldUseSingleton&&(cachedBrowserClient=client),client}function createServerClient(supabaseUrl,supabaseKey,options){if(!supabaseUrl||!supabaseKey)throw new Error("Your project's URL and Key are required to create a Supabase client!\n\nCheck your Supabase project's API settings to find these values\n\nhttps://supabase.com/dashboard/project/_/settings/api");const{storage,getAll,setAll,setItems,removedItems}=createStorageFromOptions({...options,cookieEncoding:options?.cookieEncoding??"base64url"},!0),client=createClient(supabaseUrl,supabaseKey,{...options,global:{...options?.global,headers:{...options?.global?.headers,"X-Client-Info":`supabase-ssr/${version_VERSION} createServerClient`}},auth:{...options?.cookieOptions?.name?{storageKey:options.cookieOptions.name}:null,...options?.auth,flowType:"pkce",autoRefreshToken:!1,detectSessionInUrl:!1,persistSession:!0,storage}});return client.auth.onAuthStateChange(async event=>{!(Object.keys(setItems).length>0||Object.keys(removedItems).length>0)||"SIGNED_IN"!==event&&"TOKEN_REFRESHED"!==event&&"USER_UPDATED"!==event&&"PASSWORD_RECOVERY"!==event&&"SIGNED_OUT"!==event&&"MFA_CHALLENGE_VERIFIED"!==event||await applyServerStorage({getAll,setAll,setItems,removedItems},{cookieOptions:options?.cookieOptions??null,cookieEncoding:options?.cookieEncoding??"base64url"})}),client}},"./node_modules/cookie/dist/index.js":(__unused_webpack_module,exports)=>{exports.qg=function parse(str,options){const obj=new NullObject,len=str.length;if(len<2)return obj;const dec=options?.decode||decode;let index=0;do{const eqIdx=str.indexOf("=",index);if(-1===eqIdx)break;const colonIdx=str.indexOf(";",index),endIdx=-1===colonIdx?len:colonIdx;if(eqIdx>endIdx){index=str.lastIndexOf(";",eqIdx-1)+1;continue}const keyStartIdx=startIndex(str,index,eqIdx),keyEndIdx=endIndex(str,eqIdx,keyStartIdx),key=str.slice(keyStartIdx,keyEndIdx);if(void 0===obj[key]){let valStartIdx=startIndex(str,eqIdx+1,endIdx),valEndIdx=endIndex(str,endIdx,valStartIdx);const value=dec(str.slice(valStartIdx,valEndIdx));obj[key]=value}index=endIdx+1}while(index<len);return obj},exports.lK=function serialize(name,val,options){const enc=options?.encode||encodeURIComponent;if(!cookieNameRegExp.test(name))throw new TypeError(`argument name is invalid: ${name}`);const value=enc(val);if(!cookieValueRegExp.test(value))throw new TypeError(`argument val is invalid: ${val}`);let str=name+"="+value;if(!options)return str;if(void 0!==options.maxAge){if(!Number.isInteger(options.maxAge))throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);str+="; Max-Age="+options.maxAge}if(options.domain){if(!domainValueRegExp.test(options.domain))throw new TypeError(`option domain is invalid: ${options.domain}`);str+="; Domain="+options.domain}if(options.path){if(!pathValueRegExp.test(options.path))throw new TypeError(`option path is invalid: ${options.path}`);str+="; Path="+options.path}if(options.expires){if(!function isDate(val){return"[object Date]"===__toString.call(val)}(options.expires)||!Number.isFinite(options.expires.valueOf()))throw new TypeError(`option expires is invalid: ${options.expires}`);str+="; Expires="+options.expires.toUTCString()}options.httpOnly&&(str+="; HttpOnly");options.secure&&(str+="; Secure");options.partitioned&&(str+="; Partitioned");if(options.priority){switch("string"==typeof options.priority?options.priority.toLowerCase():void 0){case"low":str+="; Priority=Low";break;case"medium":str+="; Priority=Medium";break;case"high":str+="; Priority=High";break;default:throw new TypeError(`option priority is invalid: ${options.priority}`)}}if(options.sameSite){switch("string"==typeof options.sameSite?options.sameSite.toLowerCase():options.sameSite){case!0:case"strict":str+="; SameSite=Strict";break;case"lax":str+="; SameSite=Lax";break;case"none":str+="; SameSite=None";break;default:throw new TypeError(`option sameSite is invalid: ${options.sameSite}`)}}return str};const cookieNameRegExp=/^[\u0021-\u003A\u003C\u003E-\u007E]+$/,cookieValueRegExp=/^[\u0021-\u003A\u003C-\u007E]*$/,domainValueRegExp=/^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,pathValueRegExp=/^[\u0020-\u003A\u003D-\u007E]*$/,__toString=Object.prototype.toString,NullObject=(()=>{const C=function(){};return C.prototype=Object.create(null),C})();function startIndex(str,index,max){do{const code=str.charCodeAt(index);if(32!==code&&9!==code)return index}while(++index<max);return max}function endIndex(str,index,min){for(;index>min;){const code=str.charCodeAt(--index);if(32!==code&&9!==code)return index+1}return min}function decode(str){if(-1===str.indexOf("%"))return str;try{return decodeURIComponent(str)}catch(e){return str}}}}]);